<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="dd9e511f-3a1e-4bd8-9538-ea0d0c0580e3" name="Default Changelist" comment="">
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__cheshire_5_9_0.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__ring_ring_json_0_5_0.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/vcs.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/libraries/Leiningen__cheshire_5_8_1.xml" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/libraries/Leiningen__com_fasterxml_jackson_dataformat_jackson_dataformat_cbor_2_9_6.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__com_fasterxml_jackson_dataformat_jackson_dataformat_cbor_2_9_9.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/libraries/Leiningen__com_fasterxml_jackson_dataformat_jackson_dataformat_smile_2_9_6.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__com_fasterxml_jackson_dataformat_jackson_dataformat_smile_2_9_9.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.nrepl-port" beforeDir="false" afterPath="$PROJECT_DIR$/.nrepl-port" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/compojure-api-test.iml" beforeDir="false" afterPath="$PROJECT_DIR$/compojure-api-test.iml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/project.clj" beforeDir="false" afterPath="$PROJECT_DIR$/project.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/compojure_api_test/handler.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/compojure_api_test/handler.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/compojure_api_test/mazegenerator.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/compojure_api_test/mazegenerator.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/classes/META-INF/maven/compojure-api-test/compojure-api-test/pom.properties" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/META-INF/maven/compojure-api-test/compojure-api-test/pom.properties" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/repl-port" beforeDir="false" afterPath="$PROJECT_DIR$/target/repl-port" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/stale/leiningen.core.classpath.extract-native-dependencies" beforeDir="false" afterPath="$PROJECT_DIR$/target/stale/leiningen.core.classpath.extract-native-dependencies" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="CodeStyleSettingsInfer">
    <option name="done" value="true" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="ProjectCodeStyleSettingsMigration">
    <option name="version" value="1" />
  </component>
  <component name="ProjectId" id="1YATx3OczCS7j2XDL5xjaoDTCe1" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showExcludedFiles" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">
    <property name="ASKED_ADD_EXTERNAL_FILES" value="true" />
    <property name="GoToKeyword.includeLibraries" value="false" />
    <property name="GoToNamespace.includeLibraries" value="false" />
    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
    <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
    <property name="cursive.last.file.extension.D\:/University/Year3/FunctionalProgramming/compojure-api-test/src" value="clj" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="settings.editor.selected.configurable" value="Errors" />
  </component>
  <component name="RecentsManager">
    <key name="CopyFile.RECENT_KEYS">
      <recent name="D:\University\Year3\FunctionalProgramming\compojure-api-test" />
    </key>
    <key name="MoveFile.RECENT_KEYS">
      <recent name="D:\University\Year3\FunctionalProgramming\compojure-api-test\data" />
      <recent name="D:\University\Year3\FunctionalProgramming\compojure-api-test" />
    </key>
  </component>
  <component name="ReplState" timestamp="1582902527456">{:repl-history {:ide [], :local [{:command &quot;(ns compojure-api-test.handler\n  (:require [compojure.api.sweet :refer :all]\n            [ring.util.http-response :refer :all]\n            [schema.core :as s]))\n\n(s/defschema Pizza\n  {:name s/Str\n   (s/optional-key :description) s/Str\n   :size (s/enum :L :M :S)\n   :origin {:country (s/enum :FI :PO)\n            :city s/Str}})\n\n(def app\n  (api\n    {:swagger\n     {:ui \&quot;/\&quot;\n      :spec \&quot;/swagger.json\&quot;\n      :data {:info {:title \&quot;Compojure-api-test\&quot;\n                    :description \&quot;Compojure Api example\&quot;}\n             :tags [{:name \&quot;api\&quot;, :description \&quot;some apis\&quot;}]}}}\n\n    (context \&quot;/api\&quot; []\n      :tags [\&quot;api\&quot;]\n\n      (GET \&quot;/plus\&quot; []\n        :return {:result Long}\n        :query-params [x :- Long, y :- Long]\n        :summary \&quot;adds two numbers together\&quot;\n        (ok {:result (+ x y)}))\n\n      (POST \&quot;/echo\&quot; []\n        :return Pizza\n        :body [pizza Pizza]\n        :summary \&quot;echoes a Pizza\&quot;\n        (ok pizza)))))\n&quot;, :offset 921, :ns &quot;user&quot;} {:command &quot;(ns compojure-api-test.handler\n  (:require [compojure.api.sweet :refer :all]\n            [ring.util.http-response :refer :all]\n            [schema.core :as s]\n            [clojure.data.json :as json]\n            [compojure-api-test.maze-generator]))\n\n(s/defschema Pizza\n  {:name s/Str\n   (s/optional-key :description) s/Str\n   :size (s/enum :L :M :S)\n   :origin {:country (s/enum :FI :PO)\n            :city s/Str}})\n\n(def app\n  (api\n    {:swagger\n     {:ui \&quot;/\&quot;\n      :spec \&quot;/swagger.json\&quot;\n      :data {:info {:title \&quot;Compojure-api-test\&quot;\n                    :description \&quot;Compojure Api example\&quot;}\n             :tags [{:name \&quot;ClojureMazeApi\&quot;, :description \&quot;API to access and interact with mazes generated in Clojure.\&quot;}]}}}\n\n    (context \&quot;/generator\&quot; []\n      :tags [\&quot;generator\&quot;]\n\n      (GET \&quot;/new_maze\&quot; []\n        :return {:result String}\n        :query-params [size :- Long]\n        :summary \&quot;Generates a new maze and returns it as a JSON string.\&quot;\n        (ok {:result (json/write-str {:name \&quot;Gergo Kekesi\&quot; :age 23})}))\n\n      ;(POST \&quot;/echo\&quot; []\n      ;  :return Pizza\n      ;  :body [pizza Pizza]\n      ;  :summary \&quot;echoes a Pizza\&quot;\n      ;  (ok pizza))\n      )))\n&quot;, :offset 1161, :ns &quot;user&quot;} {:command &quot;(ns compojure-api-test.handler\n  (:require [compojure.api.sweet :refer :all]\n            [ring.util.http-response :refer :all]\n            [schema.core :as s]\n            [clojure.data.json :as json]\n            [compojure-api-test.maze-generator :as maze-gen]))&quot;, :offset 262, :ns &quot;compojure-api-test.handler&quot;} {:command &quot;(ns compojure-api-test.handler\n  (:require [compojure.api.sweet :refer :all]\n            [ring.util.http-response :refer :all]\n            [schema.core :as s]\n            [clojure.data.json :as json]\n            [compojure-api-test.maze-generator]))&quot;, :offset 249, :ns &quot;compojure-api-test.handler&quot;} {:command &quot;(use 'compojure-api-test.maze-generator)&quot;, :offset 40, :ns &quot;compojure-api-test.handler&quot;} {:command &quot;(ns compojure-api-test.handler\n  (:require [compojure.api.sweet :refer :all]\n            [ring.util.http-response :refer :all]\n            [schema.core :as s]\n            [clojure.data.json :as json]\n            [compojure-api-test.mazegenerator :as mazegen]))&quot;, :offset 260, :ns &quot;compojure-api-test.handler&quot;} {:command &quot;(ns compojure-api-test.mazegenerator\n  (:require [quil.core :as q]\n            [quil.middleware :as m]\n            [clojure.string :as str]))\n\n(defn str-&gt;int [str]\n  (let [n (read-string str)]\n    (if (number? n) n nil)))\n\n(defn getImageArrayFromFile\n  [file]\n  (let [maskString (slurp file)]\n    (vec (map #(vec %) (partition 64 (mapv #(if (= 255 (str-&gt;int (first %))) 1 0) (partition 4 (str/split maskString #\&quot;,\&quot;))))))))\n\n(def mask (getImageArrayFromFile \&quot;tree_mask.txt\&quot;))\n\n(def cell {:north 0 :east 0 :south 0 :west 0 :visited 0})\n\n;The directions defs define how much to add or take away from the row and column values to go either way\n(def Direction_R {:north -1, :east 0, :south 1, :west 0})\n(def Direction_C {:north 0, :east 1, :south 0, :west -1})\n\n;This is just a helper array to map values to keywords\n(def sides [:north :east :south :west])\n(def sides_backtracker {:north 0 :east 1 :south 2 :west 3})\n\n;Set the cell at 0,0 to have been visited since we start there to generate the maze.\n(defn init-maze\n  [maze]\n  (assoc-in maze [0 0] (assoc ((maze 0) 0) :visited 1)))\n\n;To solve the maze, we use the weight keyword too so this is added to every cell and initialised at 0.\n(defn init-maze-for-solving\n  [maze]\n  (-&gt;\n    (into [] (map #(vec (map (fn [cell] (assoc cell :visited 0 :weight 0)) %)) maze))\n    (assoc-in [0 0] (assoc ((maze 0) 0) :visited 1 :weight 0))))\n\n;Generates a rectangular maze.\n(defn rectangle-maze\n  [row col]\n  (vec (take row (repeat (vec (take col (repeat cell)))))))\n\n(defn unvisited-cell?\n  [r c grid]\n  (let [cell (get-in grid [r c])\n        maskCell (get (get mask r) c)]\n    (and (= 0 (cell :visited))\n         (if (nil? maskCell) true (= 0 maskCell)))))\n\n(defn valid-unvisited-cell?\n  [r c grid]\n  (and\n    (&lt;= 0 r (dec (count grid)))\n    (&lt;= 0 c (dec (count (nth grid r))))\n    (unvisited-cell? r c grid)))\n\n(defn solver-valid-unvisited-cell?\n  [direction r c grid]\n  (and\n    (&lt;= 0 r (dec (count grid)))\n    (&lt;= 0 c (dec (count (nth grid r))))\n    (unvisited-cell? r c grid)\n    (= 1 (get (get-in grid [r c]) (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))))\n    ))\n\n(defn visit-cell\n  [r c grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :visited 1)))\n\n(defn join-cells\n  [cell1_r cell1_c cell2_r cell2_c direction grid]\n  (let [linkKey (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))]\n    (-&gt;\n      (assoc-in grid [cell1_r cell1_c] (assoc ((grid cell1_r) cell1_c) direction 1))\n      (assoc-in [cell2_r cell2_c] (assoc ((grid cell2_r) cell2_c) linkKey 1)))))\n\n(defn recursive-backtracking-maze\n  ([current_row current_col current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (if (valid-unvisited-cell? link-r link-c grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (join-cells current_row current_col link-r link-c direction)\n                   (recursive-backtracking-maze link-r link-c)) grid))) current_grid (shuffle [:north :east :south :west])))\n  ([maze] (recursive-backtracking-maze 0 0 (init-maze maze)))) ;start at a random point\n\n(defn dijkstras\n  ([current_row current_col current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (if (solver-valid-unvisited-cell? direction link-r link-c grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (addWeight link-r link-c (inc ((get-in grid [current_row current_col]) :weight)))\n                   (dijkstras link-r link-c)) grid))) current_grid (shuffle [:north :east :south :west]))\n   )\n  ([maze] (dijkstras 0 0 (init-maze-for-solving maze))))\n\n(defn make-maze [r c]\n  (recursive-backtracking-maze (rectangle-maze r c)))\n\n(defn get-drawn-maze\n  [state]\n  (let [maze (dijkstras (make-maze (state :maze-size) (state :maze-size))) margin 70]\n    (q/fill 0)\n    (q/background 240)\n    (q/line margin margin (- (state :width) margin) margin)\n    (let [y-cell-size (/ (- (state :height) (* 2 margin)) (count maze))\n          x-cell-size (/ (- (state :width) (* 2 margin)) (-&gt; maze first count))]\n      (dotimes [y (count maze)]\n        (let [yv (+ margin (* y y-cell-size))\n              yv2 (+ y-cell-size yv)]\n          (q/line margin yv margin yv2)\n          (dotimes [x (-&gt; maze first count)]\n            (let [xv (+ margin (* x x-cell-size))\n                  xv2 (+ x-cell-size xv)]\n              ;(if (= 0 ((mget x y maze) :south) (q/line xv yv2 xv2 yv2))\n              ;(if (not= 0 ((mget x y maze) :north))\n              ;  (when (= 0 ((mget x y maze) :east) (q/line xv yv2 xv2 yv2))\n              ;  (q/line xv2 yv xv2 yv2))))\n              (let [cell (get-in maze [y x])\n                    maskCell (get (get mask y) x)]\n                (if (or (nil? maskCell) (= 0 maskCell)) (do\n                                                          (if (= 0 (cell :visited))\n                                                            (do\n                                                              (q/fill 200 255 200)\n                                                              (q/no-stroke)\n                                                              (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))\n                                                            (do\n                                                              (q/fill (- 255 (cell :weight)) 50 100)\n                                                              (q/no-stroke)\n                                                              (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))))\n                                                        (do\n                                                          (q/fill 100 255 100)\n                                                          (q/no-stroke)\n                                                          (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)\n                                                          )\n                                                        )\n                (q/stroke 0)\n                (q/stroke-weight 5)\n                (q/fill 0)\n                (when (= 0 (cell :east)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv2 yv xv2 yv2)))\n                (when (= 0 (cell :west)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv yv2)))\n                (when (= 0 (cell :south)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv2 xv2 yv2)))\n                (when (= 0 (cell :north)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv2 yv)))\n                (when (&gt; 14 (count maze)) (q/text-size 20))\n                (when (&gt; 14 (count maze)) (q/text (str (cell :weight)) (+ xv (/ x-cell-size 2)) (+ yv (/ y-cell-size 2))))))))))))\n(q/sketch\n  :draw (fn []\n          (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                       (q/no-loop)\n                       (get-drawn-maze {:maze-size 32 :width 750 :height 750})\n                       )\n          (q/exit)\n          ))&quot;, :offset 7182, :ns &quot;compojure-api-test.handler&quot;} {:command &quot;(ns compojure-api-test.mazegenerator\n  (:require [quil.core :as q]\n            [quil.middleware :as m]\n            [clojure.string :as str]))\n\n(defn str-&gt;int [str]\n  (let [n (read-string str)]\n    (if (number? n) n nil)))\n\n(defn getImageArrayFromFile\n  [file]\n  (let [maskString (slurp file)]\n    (vec (map #(vec %) (partition 64 (mapv #(if (= 255 (str-&gt;int (first %))) 1 0) (partition 4 (str/split maskString #\&quot;,\&quot;))))))))\n\n(def mask (getImageArrayFromFile \&quot;tree_mask.txt\&quot;))\n\n(def cell {:north 0 :east 0 :south 0 :west 0 :visited 0})\n\n;The directions defs define how much to add or take away from the row and column values to go either way\n(def Direction_R {:north -1, :east 0, :south 1, :west 0})\n(def Direction_C {:north 0, :east 1, :south 0, :west -1})\n\n;This is just a helper array to map values to keywords\n(def sides [:north :east :south :west])\n(def sides_backtracker {:north 0 :east 1 :south 2 :west 3})\n\n;Set the cell at 0,0 to have been visited since we start there to generate the maze.\n(defn init-maze\n  [maze]\n  (assoc-in maze [0 0] (assoc ((maze 0) 0) :visited 1)))\n\n;To solve the maze, we use the weight keyword too so this is added to every cell and initialised at 0.\n(defn init-maze-for-solving\n  [maze]\n  (-&gt;\n    (into [] (map #(vec (map (fn [cell] (assoc cell :visited 0 :weight 0)) %)) maze))\n    (assoc-in [0 0] (assoc ((maze 0) 0) :visited 1 :weight 0))))\n\n;Generates a rectangular maze.\n(defn rectangle-maze\n  [row col]\n  (vec (take row (repeat (vec (take col (repeat cell)))))))\n\n(defn unvisited-cell?\n  [r c grid]\n  (let [cell (get-in grid [r c])\n        maskCell (get (get mask r) c)]\n    (and (= 0 (cell :visited))\n         (if (nil? maskCell) true (= 0 maskCell)))))\n\n(defn valid-unvisited-cell?\n  [r c grid]\n  (and\n    (&lt;= 0 r (dec (count grid)))\n    (&lt;= 0 c (dec (count (nth grid r))))\n    (unvisited-cell? r c grid)))\n\n(defn solver-valid-unvisited-cell?\n  [direction r c grid]\n  (and\n    (&lt;= 0 r (dec (count grid)))\n    (&lt;= 0 c (dec (count (nth grid r))))\n    (unvisited-cell? r c grid)\n    (= 1 (get (get-in grid [r c]) (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))))\n    ))\n\n(defn visit-cell\n  [r c grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :visited 1)))\n\n(defn join-cells\n  [cell1_r cell1_c cell2_r cell2_c direction grid]\n  (let [linkKey (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))]\n    (-&gt;\n      (assoc-in grid [cell1_r cell1_c] (assoc ((grid cell1_r) cell1_c) direction 1))\n      (assoc-in [cell2_r cell2_c] (assoc ((grid cell2_r) cell2_c) linkKey 1)))))\n\n(defn recursive-backtracking-maze\n  ([current_row current_col current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (if (valid-unvisited-cell? link-r link-c grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (join-cells current_row current_col link-r link-c direction)\n                   (recursive-backtracking-maze link-r link-c)) grid))) current_grid (shuffle [:north :east :south :west])))\n  ([maze] (recursive-backtracking-maze 0 0 (init-maze maze)))) ;start at a random point\n\n(defn addWeight\n  [r c weight grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :weight weight)))\n\n(defn dijkstras\n  ([current_row current_col current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (if (solver-valid-unvisited-cell? direction link-r link-c grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (addWeight link-r link-c (inc ((get-in grid [current_row current_col]) :weight)))\n                   (dijkstras link-r link-c)) grid))) current_grid (shuffle [:north :east :south :west]))\n   )\n  ([maze] (dijkstras 0 0 (init-maze-for-solving maze))))\n\n(defn make-maze [r c]\n  (recursive-backtracking-maze (rectangle-maze r c)))\n\n(defn get-drawn-maze\n  [state]\n  (let [maze (dijkstras (make-maze (state :maze-size) (state :maze-size))) margin 70]\n    (q/fill 0)\n    (q/background 240)\n    (q/line margin margin (- (state :width) margin) margin)\n    (let [y-cell-size (/ (- (state :height) (* 2 margin)) (count maze))\n          x-cell-size (/ (- (state :width) (* 2 margin)) (-&gt; maze first count))]\n      (dotimes [y (count maze)]\n        (let [yv (+ margin (* y y-cell-size))\n              yv2 (+ y-cell-size yv)]\n          (q/line margin yv margin yv2)\n          (dotimes [x (-&gt; maze first count)]\n            (let [xv (+ margin (* x x-cell-size))\n                  xv2 (+ x-cell-size xv)]\n              ;(if (= 0 ((mget x y maze) :south) (q/line xv yv2 xv2 yv2))\n              ;(if (not= 0 ((mget x y maze) :north))\n              ;  (when (= 0 ((mget x y maze) :east) (q/line xv yv2 xv2 yv2))\n              ;  (q/line xv2 yv xv2 yv2))))\n              (let [cell (get-in maze [y x])\n                    maskCell (get (get mask y) x)]\n                (if (or (nil? maskCell) (= 0 maskCell)) (do\n                                                          (if (= 0 (cell :visited))\n                                                            (do\n                                                              (q/fill 200 255 200)\n                                                              (q/no-stroke)\n                                                              (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))\n                                                            (do\n                                                              (q/fill (- 255 (cell :weight)) 50 100)\n                                                              (q/no-stroke)\n                                                              (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))))\n                                                        (do\n                                                          (q/fill 100 255 100)\n                                                          (q/no-stroke)\n                                                          (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)\n                                                          )\n                                                        )\n                (q/stroke 0)\n                (q/stroke-weight 5)\n                (q/fill 0)\n                (when (= 0 (cell :east)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv2 yv xv2 yv2)))\n                (when (= 0 (cell :west)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv yv2)))\n                (when (= 0 (cell :south)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv2 xv2 yv2)))\n                (when (= 0 (cell :north)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv2 yv)))\n                (when (&gt; 14 (count maze)) (q/text-size 20))\n                (when (&gt; 14 (count maze)) (q/text (str (cell :weight)) (+ xv (/ x-cell-size 2)) (+ yv (/ y-cell-size 2))))))))))))\n(q/sketch\n  :draw (fn []\n          (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                       (q/no-loop)\n                       (get-drawn-maze {:maze-size 32 :width 750 :height 750})\n                       )\n          (q/exit)\n          ))&quot;, :offset 7280, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(q/sketch\n  :draw (fn []\n          (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                       (q/no-loop)\n                       (get-drawn-maze {:maze-size 64 :width 750 :height 750})\n                       )\n          (q/exit)\n          ))&quot;, :offset 262, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(def *agnt* (agent {}))&quot;, :offset 23, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(send-off *agnt* (fn [state]\n                   (q/sketch\n                     :draw (fn []\n                             (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                                          (q/no-loop)\n                                          (get-drawn-maze {:maze-size 64 :width 750 :height 750})\n                                          )\n                             (q/exit)\n                             ))\n                   (assoc state :done true)))&quot;, :offset 489, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(send-off *agnt* (fn [state]\n                   (q/sketch\n                     :draw (fn []\n                             (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                                          (q/no-loop)\n                                          (get-drawn-maze {:maze-size 32 :width 750 :height 750})\n                                          )\n                             (q/exit)\n                             ))\n                   (assoc state :done true)))&quot;, :offset 489, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(await *agnt*)&quot;, :offset 14, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(defn create-maze\n  []\n  (let [*agnt* (agent {})]\n    (send-off *agnt* (fn [state]\n                       (q/sketch\n                         :draw (fn []\n                                 (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                                              (q/no-loop)\n                                              (get-drawn-maze {:maze-size 32 :width 750 :height 750})\n                                              )\n                                 (q/exit)\n                                 ))\n                       (assoc state :done true)))\n\n    (await *agnt*)\n    ))&quot;, :offset 606, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(defn create-maze\n  []\n  (let [*agnt* (agent {})]\n    (send-off *agnt* (fn [state]\n                       (q/sketch\n                         :draw (fn []\n                                 (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                                              (q/no-loop)\n                                              (get-drawn-maze {:maze-size 32 :width 750 :height 750})\n                                              )\n                                 (q/exit)\n                                 (Thread/sleep 2000)\n                                 ))\n                       (assoc state :done true)))\n\n    (await *agnt*)\n    (println \&quot;Hello\&quot;)\n    ))&quot;, :offset 681, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(defn create-maze\n  []\n  (let [*agnt* (agent {})]\n    (send-off *agnt* (fn [state]\n                       (q/sketch\n                         :draw (fn []\n                                 (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                                              (q/no-loop)\n                                              (get-drawn-maze {:maze-size 32 :width 750 :height 750})\n                                              )\n                                 (q/exit)\n                                 (Thread/sleep 3000)\n                                 ))\n                       (assoc state :done true)))\n\n    (await *agnt*)\n    (println \&quot;Hello\&quot;)\n    ))&quot;, :offset 681, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(defn create-maze\n  []\n  (let [*agnt* (agent {})]\n    (send-off *agnt* (fn [state]\n                       (q/sketch\n                         :draw (fn []\n                                 (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                                              (q/no-loop)\n                                              (get-drawn-maze {:maze-size 32 :width 750 :height 750})\n                                              )\n                                 (q/exit)\n                                 \n                                 ))\n                       (Thread/sleep 3000)\n                       (assoc state :done true)))\n\n    (await *agnt*)\n    (println \&quot;Hello\&quot;)\n    ))&quot;, :offset 705, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(create-maze)&quot;, :offset 13, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(ns compojure-api-test.handler\n  (:require [compojure.api.sweet :refer :all]\n            [ring.util.http-response :refer :all]\n            [schema.core :as s]\n            [clojure.data.json :as json]\n            [compojure-api-test.mazegenerator :as mazegen]\n            [juxt.dirwatch :as dirwatch]\n            [clojure.java.io :as io]))&quot;, :offset 338, :ns &quot;user&quot;} {:command &quot;(.exists (io/as-file \&quot;test.svg\&quot;))&quot;, :offset 33, :ns &quot;compojure-api-test.handler&quot;} {:command &quot;(ns compojure-api-test.mazegenerator\n  (:require [quil.core :as q]\n            [quil.middleware :as m]\n            [clojure.string :as str]))\n\n(defn str-&gt;int [str]\n  (let [n (read-string str)]\n    (if (number? n) n nil)))\n\n(defn getImageArrayFromFile\n  [file]\n  (let [maskString (slurp file)]\n    (vec (map #(vec %) (partition 64 (mapv #(if (= 255 (str-&gt;int (first %))) 1 0) (partition 4 (str/split maskString #\&quot;,\&quot;))))))))\n\n(def mask (getImageArrayFromFile \&quot;tree_mask.txt\&quot;))\n\n(def cell {:north 0 :east 0 :south 0 :west 0 :visited 0})\n\n;The directions defs define how much to add or take away from the row and column values to go either way\n(def Direction_R {:north -1, :east 0, :south 1, :west 0})\n(def Direction_C {:north 0, :east 1, :south 0, :west -1})\n\n;This is just a helper array to map values to keywords\n(def sides [:north :east :south :west])\n(def sides_backtracker {:north 0 :east 1 :south 2 :west 3})\n\n;Set the cell at 0,0 to have been visited since we start there to generate the maze.\n(defn init-maze\n  [maze]\n  (assoc-in maze [0 0] (assoc ((maze 0) 0) :visited 1)))\n\n;To solve the maze, we use the weight keyword too so this is added to every cell and initialised at 0.\n(defn init-maze-for-solving\n  [maze]\n  (-&gt;\n    (into [] (map #(vec (map (fn [cell] (assoc cell :visited 0 :weight 0)) %)) maze))\n    (assoc-in [0 0] (assoc ((maze 0) 0) :visited 1 :weight 0))))\n\n;Generates a rectangular maze.\n(defn rectangle-maze\n  [row col]\n  (vec (take row (repeat (vec (take col (repeat cell)))))))\n\n(defn unvisited-cell?\n  [r c grid]\n  (let [cell (get-in grid [r c])\n        maskCell (get (get mask r) c)]\n    (and (= 0 (cell :visited))\n         (if (nil? maskCell) true (= 0 maskCell)))))\n\n(defn valid-unvisited-cell?\n  [r c grid]\n  (and\n    (&lt;= 0 r (dec (count grid)))\n    (&lt;= 0 c (dec (count (nth grid r))))\n    (unvisited-cell? r c grid)))\n\n(defn solver-valid-unvisited-cell?\n  [direction r c grid]\n  (and\n    (&lt;= 0 r (dec (count grid)))\n    (&lt;= 0 c (dec (count (nth grid r))))\n    (unvisited-cell? r c grid)\n    (= 1 (get (get-in grid [r c]) (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))))\n    ))\n\n(defn visit-cell\n  [r c grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :visited 1)))\n\n(defn join-cells\n  [cell1_r cell1_c cell2_r cell2_c direction grid]\n  (let [linkKey (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))]\n    (-&gt;\n      (assoc-in grid [cell1_r cell1_c] (assoc ((grid cell1_r) cell1_c) direction 1))\n      (assoc-in [cell2_r cell2_c] (assoc ((grid cell2_r) cell2_c) linkKey 1)))))\n\n(defn recursive-backtracking-maze\n  ([current_row current_col current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (if (valid-unvisited-cell? link-r link-c grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (join-cells current_row current_col link-r link-c direction)\n                   (recursive-backtracking-maze link-r link-c)) grid))) current_grid (shuffle [:north :east :south :west])))\n  ([maze] (recursive-backtracking-maze 0 0 (init-maze maze)))) ;start at a random point\n\n(defn addWeight\n  [r c weight grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :weight weight)))\n\n(defn dijkstras\n  ([current_row current_col current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (if (solver-valid-unvisited-cell? direction link-r link-c grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (addWeight link-r link-c (inc ((get-in grid [current_row current_col]) :weight)))\n                   (dijkstras link-r link-c)) grid))) current_grid (shuffle [:north :east :south :west]))\n   )\n  ([maze] (dijkstras 0 0 (init-maze-for-solving maze))))\n\n(defn make-maze [r c]\n  (recursive-backtracking-maze (rectangle-maze r c)))\n\n(defn get-drawn-maze\n  [state]\n  (let [maze (dijkstras (make-maze (state :maze-size) (state :maze-size))) margin 70]\n    (q/fill 0)\n    (q/background 240)\n    (q/line margin margin (- (state :width) margin) margin)\n    (let [y-cell-size (/ (- (state :height) (* 2 margin)) (count maze))\n          x-cell-size (/ (- (state :width) (* 2 margin)) (-&gt; maze first count))]\n      (dotimes [y (count maze)]\n        (let [yv (+ margin (* y y-cell-size))\n              yv2 (+ y-cell-size yv)]\n          (q/line margin yv margin yv2)\n          (dotimes [x (-&gt; maze first count)]\n            (let [xv (+ margin (* x x-cell-size))\n                  xv2 (+ x-cell-size xv)]\n              ;(if (= 0 ((mget x y maze) :south) (q/line xv yv2 xv2 yv2))\n              ;(if (not= 0 ((mget x y maze) :north))\n              ;  (when (= 0 ((mget x y maze) :east) (q/line xv yv2 xv2 yv2))\n              ;  (q/line xv2 yv xv2 yv2))))\n              (let [cell (get-in maze [y x])\n                    maskCell (get (get mask y) x)]\n                (if (or (nil? maskCell) (= 0 maskCell)) (do\n                                                          (if (= 0 (cell :visited))\n                                                            (do\n                                                              (q/fill 200 255 200)\n                                                              (q/no-stroke)\n                                                              (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))\n                                                            (do\n                                                              (q/fill (- 255 (cell :weight)) 50 100)\n                                                              (q/no-stroke)\n                                                              (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))))\n                                                        (do\n                                                          (q/fill 100 255 100)\n                                                          (q/no-stroke)\n                                                          (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)\n                                                          )\n                                                        )\n                (q/stroke 0)\n                (q/stroke-weight 5)\n                (q/fill 0)\n                (when (= 0 (cell :east)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv2 yv xv2 yv2)))\n                (when (= 0 (cell :west)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv yv2)))\n                (when (= 0 (cell :south)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv2 xv2 yv2)))\n                (when (= 0 (cell :north)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv2 yv)))\n                (when (&gt; 14 (count maze)) (q/text-size 20))\n                (when (&gt; 14 (count maze)) (q/text (str (cell :weight)) (+ xv (/ x-cell-size 2)) (+ yv (/ y-cell-size 2))))))))))))\n\n(defn create-maze\n  [size]\n  (let [*agnt* (agent {})]\n    (send-off *agnt* (fn [state]\n                       (q/sketch\n                         :draw (fn []\n                                 (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                                              (q/no-loop)\n                                              (get-drawn-maze {:maze-size size :width 750 :height 750})\n                                              )\n                                 (q/exit)\n\n                                 ))\n                       (assoc state :done true)))\n\n    (await *agnt*)\n    ))\n\n;(q/sketch\n;  :draw (fn []\n;          (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n;                       (q/no-loop)\n;                       (get-drawn-maze {:maze-size 64 :width 750 :height 750})\n;                       )\n;          (q/exit)\n;          ))&quot;, :offset 7904, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(ns compojure-api-test.handler\n  (:require [compojure.api.sweet :refer :all]\n            [ring.util.http-response :refer :all]\n            [schema.core :as s]\n            [clojure.data.json :as json]\n            [compojure-api-test.mazegenerator :as mazegen]\n            [juxt.dirwatch :as dirwatch]\n            [clojure.java.io :as io]\n            [ring.middleware.cors :refer [wrap-cors]]))&quot;, :offset 392, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(json/write-str (dijkstras (make-maze 5 5)))&quot;, :offset 44, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(json/write-str (mazegen/dijkstras (mazegen/make-maze 5 5)))&quot;, :offset 60, :ns &quot;compojure-api-test.handler&quot;} {:command &quot;(ns compojure-api-test.queries\n  (:require [clojure.java.jdbc :as jdbc]))&quot;, :offset 73, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(let\n  [db-spec {:subprotocol \&quot;h2\&quot;\n            :subname \&quot;./data/mazes\&quot;\n            :user \&quot;sa\&quot;\n            :password \&quot;\&quot;}\n   details (jdbc/query db-spec\n                       [\&quot;select * from mazes\&quot;])])&quot;, :offset 200, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(let\n  [db-spec {:subprotocol \&quot;h2\&quot;\n            :subname \&quot;./data/mazes\&quot;\n            :user \&quot;sa\&quot;\n            :password \&quot;\&quot;}\n   details (jdbc/query db-spec\n                       [\&quot;select * from MAZES\&quot;])])&quot;, :offset 200, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(let\n  [db-spec {:subprotocol \&quot;h2\&quot;\n            :subname \&quot;./data/mazes\&quot;\n            :user \&quot;sa\&quot;\n            :password \&quot;\&quot;}\n   details (jdbc/query db-spec\n                       [\&quot;select * from mazes\&quot;])]\n  details)&quot;, :offset 210, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(ns compojure-api-test.queries\n  (:require [clojure.java.jdbc :as jdbc])\n  (:import (java.io BufferedReader)))&quot;, :offset 110, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn clob-to-string [row]\n  (assoc row :review\n             (with-open [rdr (BufferedReader.\n                               (.getCharacterStream (:review row)))]\n               (apply str (line-seq rdr)))))&quot;, :offset 207, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn clob-to-string [row]\n  (assoc row :review\n             (with-open [rdr (java.io.BufferedReader.\n                               (.getCharacterStream (:review row)))]\n               (apply str (line-seq rdr)))))&quot;, :offset 215, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(ns compojure-api-test.queries\n  (:require [clojure.java.jdbc :as jdbc]))\n\n(defn clob-to-string [row]\n  (assoc row :review\n             (with-open [rdr (java.io.BufferedReader.\n                               (.getCharacterStream (:review row)))]\n               (apply str (line-seq rdr)))))\n\n\n(let\n  [db-spec {:subprotocol \&quot;h2\&quot;\n            :subname \&quot;./data/mazes\&quot;\n            :user \&quot;sa\&quot;\n            :password \&quot;\&quot;}\n   details (jdbc/query db-spec\n                       [\&quot;select * from mazes\&quot;]\n                       {:row-fn clob-to-string})]\n  details)\n\n&quot;, :offset 553, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn clob-to-string [row]\n  (assoc row :json\n             (with-open [rdr (java.io.BufferedReader. (.getCharacterStream (:json row)))]\n               (apply str (line-seq rdr)))))&quot;, :offset 180, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(let\n  [db-spec {:subprotocol \&quot;h2\&quot;\n            :subname \&quot;./data/mazes\&quot;\n            :user \&quot;sa\&quot;\n            :password \&quot;\&quot;}\n   details (jdbc/query db-spec\n                       [\&quot;select * from mazes\&quot;]\n                       {:row-fn clob-to-string})]\n  details)&quot;, :offset 258, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(def db-spec {:subprotocol \&quot;h2\&quot;\n              :subname \&quot;./data/mazes\&quot;\n              :user \&quot;sa\&quot;\n              :password \&quot;\&quot;})&quot;, :offset 123, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(let\n  [details (jdbc/query db-spec\n                       [\&quot;insert into mazes (width, height)\n                       values (1, 2);\&quot;]\n                       )]\n  details)&quot;, :offset 171, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(let\n  [details (jdbc/execute! db-spec\n                       [\&quot;insert into mazes (width, height)\n                       values (1, 2);\&quot;]\n                       )]\n  details)&quot;, :offset 174, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn insert_maze\n  [width height json svg]\n  (let\n    [details (jdbc/execute! db-spec\n                            [(str \&quot;insert into mazes (width, height, json, svg)\n                              values (\&quot; width \&quot;,\&quot;\n                                        height \&quot;,\&quot;\n                                        json \&quot;,\&quot;\n                                        svg \&quot;);\&quot;)]\n                            )]\n    details))&quot;, :offset 412, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn insert_maze\n  \&quot;width: int\n   height: int\n   json: json stringified already\n   svg: string svg xml\&quot;\n  [width height json svg]\n  (let\n    [details (jdbc/execute! db-spec\n                            [(str \&quot;insert into mazes (width, height, json, svg)\n                              values (\&quot; width \&quot;,\&quot;\n                                        height \&quot;,\&quot;\n                                        json \&quot;,\&quot;\n                                        svg \&quot;);\&quot;)]\n                            )]\n    details))&quot;, :offset 499, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(let\n  [details (jdbc/execute! db-spec\n                          [\&quot;insert into mazes (width, height)\n                       values (1, 2);\&quot;]\n                          )]\n  details)&quot;, :offset 180, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(let\n  [details (jdbc/execute! db-spec\n                          [\&quot;SELECT TOP 1 maze_id FROM Table ORDER BY ID DESC\&quot;]\n                          )]\n  details)&quot;, :offset 157, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(let\n  [details (jdbc/execute! db-spec\n                          [\&quot;SELECT TOP 1 maze_id FROM mazes ORDER BY maze_id DESC\&quot;]\n                          )]\n  details)&quot;, :offset 162, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(let\n  [details (jdbc/query db-spec\n                          [\&quot;SELECT TOP 1 maze_id FROM mazes ORDER BY maze_id DESC\&quot;]\n                          )]\n  details)&quot;, :offset 159, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn insert_maze\n  \&quot;width: int\n   height: int\n   json: json stringified already\n   svg: string svg xml\&quot;\n  [width height json svg]\n  (let\n    [success (jdbc/execute! db-spec\n                            [(str \&quot;INSERT INTO mazes (width, height, json, svg)\n                              VALUES (\&quot; width \&quot;,\&quot;\n                                        height \&quot;,\&quot;\n                                        json \&quot;,\&quot;\n                                        svg \&quot;);\&quot;)]\n                            )]\n    (if success (conj {:succesds true} (jdbc/query db-spec [\&quot;SELECT TOP 1 maze_id FROM mazes ORDER BY maze_id DESC\&quot;]))\n                {:success false :maze-id -1})))&quot;, :offset 652, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn insert_maze\n  \&quot;width: int\n   height: int\n   json: json stringified already\n   svg: string svg xml\&quot;\n  [width height json svg]\n  (let\n    [success (jdbc/execute! db-spec\n                            [(str \&quot;INSERT INTO mazes (width, height, json, svg)\n                              VALUES (\&quot; width \&quot;,\&quot;\n                                        height \&quot;,\&quot;\n                                        json \&quot;,\&quot;\n                                        (if (empty? svg) \&quot;\&quot; svg) \n                                     \&quot;);\&quot;)]\n                            )]\n    (if success (conj {:succesds true} (jdbc/query db-spec [\&quot;SELECT TOP 1 maze_id FROM mazes ORDER BY maze_id DESC\&quot;]))\n                {:success false :maze-id -1})))&quot;, :offset 711, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn insert-maze\n  \&quot;width: int\n   height: int\n   json: json stringified already\n   svg: string svg xml\&quot;\n  [width height json svg]\n  (let\n    [success (jdbc/execute! db-spec\n                            [(str \&quot;INSERT INTO mazes (width, height, json, svg)\n                              VALUES (\&quot; width \&quot;,\&quot;\n                                        height \&quot;,\&quot;\n                                        json \&quot;,\&quot;\n                                        (if (empty? svg) \&quot;\&quot; svg)\n                                     \&quot;);\&quot;)]\n                            )]\n    (if success (conj {:succesds true} (jdbc/query db-spec [\&quot;SELECT TOP 1 maze_id FROM mazes ORDER BY maze_id DESC\&quot;]))\n                {:success false :maze-id -1})))&quot;, :offset 710, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(insert-maze 1 1 \&quot;{}\&quot;)&quot;, :offset 22, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn insert-maze\n  \&quot;width: int\n   height: int\n   json: json stringified already\n   svg: string svg xml\&quot;\n  [width height json svg]\n  (let\n    [success (jdbc/execute! db-spec\n                            [(str \&quot;INSERT INTO mazes (width, height, json, svg)\n                              VALUES (\&quot; width \&quot;,\&quot;\n                                        height \&quot;,\&quot;\n                                        json\n                                        (if (empty? svg) \&quot;\&quot; (str \&quot;,\&quot; svg))\n                                     \&quot;);\&quot;)]\n                            )]\n    (if success (conj {:succesds true} (jdbc/query db-spec [\&quot;SELECT TOP 1 maze_id FROM mazes ORDER BY maze_id DESC\&quot;]))\n                {:success false :maze-id -1})))&quot;, :offset 716, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn insert-maze\n  \&quot;width: int\n   height: int\n   json: json stringified already\n   svg: string svg xml\&quot;\n  [width height json svg]\n  (let\n    [success (jdbc/execute! db-spec\n                            [(str \&quot;INSERT INTO mazes (width, height, json, svg)\n                              VALUES (\&quot; width \&quot;,\&quot;\n                                        height \&quot;,'\&quot;\n                                        json \&quot;'\&quot;\n                                        (if (empty? svg) \&quot;\&quot; (str \&quot;,\&quot; svg))\n                                     \&quot;);\&quot;)]\n                            )]\n    (if success (conj {:succesds true} (jdbc/query db-spec [\&quot;SELECT TOP 1 maze_id FROM mazes ORDER BY maze_id DESC\&quot;]))\n                {:success false :maze-id -1})))&quot;, :offset 721, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn insert-maze\n  \&quot;width: int\n   height: int\n   json: json stringified already\n   svg: string svg xml\&quot;\n  [width height json svg]\n  (let\n    [success (jdbc/execute! db-spec\n                            [(str \&quot;INSERT INTO mazes (width, height, json, svg)\n                              VALUES (\&quot; width \&quot;,\&quot;\n                                        height \&quot;,'\&quot;\n                                        json \&quot;'\&quot;\n                                        (if (empty? svg) \&quot;''\&quot; (str \&quot;,'\&quot; svg \&quot;'\&quot;))\n                                     \&quot;);\&quot;)]\n                            )]\n    (if success (conj {:succesds true} (jdbc/query db-spec [\&quot;SELECT TOP 1 maze_id FROM mazes ORDER BY maze_id DESC\&quot;]))\n                {:success false :maze-id -1})))&quot;, :offset 728, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn insert-maze\n  \&quot;width: int\n   height: int\n   json: json stringified already\n   svg: string svg xml\&quot;\n  [width height json svg]\n  (let\n    [success (jdbc/execute! db-spec\n                            [(str \&quot;INSERT INTO mazes (width, height, json, svg)\n                              VALUES (\&quot; width \&quot;,\&quot;\n                                        height \&quot;,'\&quot;\n                                        json \&quot;',\&quot;\n                                        (if (empty? svg) \&quot;''\&quot; (str \&quot;'\&quot; svg \&quot;'\&quot;))\n                                     \&quot;);\&quot;)]\n                            )]\n    (if success (conj {:succesds true} (jdbc/query db-spec [\&quot;SELECT TOP 1 maze_id FROM mazes ORDER BY maze_id DESC\&quot;]))\n                {:success false :maze-id -1})))&quot;, :offset 728, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn insert-maze\n  \&quot;width: int\n   height: int\n   json: json stringified already\n   svg: string svg xml\&quot;\n  [width height json svg]\n  (let\n    [success (jdbc/execute! db-spec\n                            [(str \&quot;INSERT INTO mazes (width, height, json, svg)\n                              VALUES (\&quot; width \&quot;,\&quot;\n                                        height \&quot;,'\&quot;\n                                        json \&quot;',\&quot;\n                                        (if (empty? svg) \&quot;''\&quot; (str \&quot;'\&quot; svg \&quot;'\&quot;))\n                                     \&quot;);\&quot;)]\n                            )]\n    (if success (conj {:succesds true} (first (jdbc/query db-spec [\&quot;SELECT TOP 1 maze_id FROM mazes ORDER BY maze_id DESC\&quot;])))\n                {:success false :maze-id -1})))&quot;, :offset 736, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(insert-maze 1 1 \&quot;{}\&quot; \&quot;\&quot;)&quot;, :offset 25, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn update-maze-svg\n   \&quot;maze-id: int\n    svg: string svg xml\&quot;\n  [maze-id svg]\n  (let\n    [success (jdbc/execute! db-spec\n                            [(str \&quot;UPDATE mazes\n                                   SET svg = '\&quot; svg \&quot;' \&quot;\n                                  \&quot;WHERE maze_id = \&quot; maze-id                           \n                            )])]\n    {:success success}))&quot;, :offset 373, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn update-maze-svg\n   \&quot;maze-id: int\n    svg: string svg xml\&quot;\n  [maze-id svg]\n  (let\n    [success (jdbc/execute! db-spec\n                            [(str \&quot;UPDATE mazes\n                                   SET svg = '\&quot; svg \&quot;' \&quot;\n                                  \&quot;WHERE maze_id = \&quot; maze-id\n                            )])]\n    {:success (boolean (first success))}))&quot;, :offset 364, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(update-maze-svg 1 \&quot;test\&quot;)&quot;, :offset 26, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(def tables {\n             :mazes \&quot;mazes\&quot;\n             :weighted_mazes \&quot;weighted_mazes\&quot;\n             :maze_solutions \&quot;maze_solutions\&quot;\n             })&quot;, :offset 149, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(def tables {\n             :mazes {:name \&quot;mazes\&quot; :id-col \&quot;maze_id\&quot;}\n             :weighted_mazes {:name \&quot;weighted_mazes\&quot; :id-col \&quot;weighted_maze_id\&quot;}\n             :maze_solutions {:name \&quot;maze_solutions\&quot; :id-col \&quot;maze_solution_id\&quot;}\n             })&quot;, :offset 245, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn update-maze-svg\n   \&quot;table: keyword from table def\n    id: int\n    svg: stringified svg xml\&quot;\n  [table id svg]\n  (let\n    [success (jdbc/execute! db-spec\n                            [(str \&quot;UPDATE \&quot; ((tables :table) :name)\n                                  \&quot;SET svg = '\&quot; svg \&quot;' \&quot;\n                                  \&quot;WHERE \&quot; ((tables :table) :id-col) \&quot; = \&quot; id\n                            )])]\n    {:success (boolean (first success))}))&quot;, :offset 436, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn update-maze-svg\n   \&quot;table: keyword from table def\n    id: int\n    svg: stringified svg xml\&quot;\n  [table id svg]\n  (let\n    [success (jdbc/execute! db-spec\n                            [(str \&quot;UPDATE \&quot; ((tables table) :name)\n                                  \&quot;SET svg = '\&quot; svg \&quot;' \&quot;\n                                  \&quot;WHERE \&quot; ((tables table) :id-col) \&quot; = \&quot; id\n                            )])]\n    {:success (boolean (first success))}))&quot;, :offset 434, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(defn update-maze-svg\n   \&quot;table: keyword from table def\n    id: int\n    svg: stringified svg xml\&quot;\n  [table id svg]\n  (let\n    [success (jdbc/execute! db-spec\n                            [(str \&quot;UPDATE \&quot; ((tables table) :name) \&quot; \&quot;\n                                  \&quot;SET svg = '\&quot; svg \&quot;' \&quot;\n                                  \&quot;WHERE \&quot; ((tables table) :id-col) \&quot; = \&quot; id\n                            )])]\n    {:success (boolean (first success))}))&quot;, :offset 438, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(update-maze-svg :mazes 1 \&quot;helllo\&quot;)&quot;, :offset 35, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(update-maze-svg :mazes 1 \&quot;\&quot;)&quot;, :offset 29, :ns &quot;compojure-api-test.queries&quot;} {:command &quot;(ns compojure-api-test.mazegenerator\n  (:require [quil.core :as q]\n            [quil.middleware :as m]\n            [clojure.string :as str]))\n\n(defn str-&gt;int [str]\n  (let [n (read-string str)]\n    (if (number? n) n nil)))\n\n(defn getImageArrayFromString\n  [mask]\n  (let [maskString mask]\n    (vec (map #(vec %) (partition 64 (mapv #(if (= 255 (str-&gt;int (first %))) 1 0) (partition 4 (str/split maskString #\&quot;,\&quot;))))))))\n\n(def cell {:north 0 :east 0 :south 0 :west 0 :visited 0})\n\n;The directions defs define how much to add or take away from the row and column values to go either way\n(def Direction_R {:north -1, :east 0, :south 1, :west 0})\n(def Direction_C {:north 0, :east 1, :south 0, :west -1})\n\n;This is just a helper array to map values to keywords\n(def sides [:north :east :south :west])\n(def sides_backtracker {:north 0 :east 1 :south 2 :west 3})\n\n;Set the cell at 0,0 to have been visited since we start there to generate the maze.\n(defn init-maze\n  [maze]\n  (assoc-in maze [0 0] (assoc ((maze 0) 0) :visited 1)))\n\n;To solve the maze, we use the weight keyword too so this is added to every cell and initialised at 0.\n(defn init-maze-for-solving\n  [maze]\n  (-&gt;\n    (into [] (map #(vec (map (fn [cell] (assoc cell :visited 0 :weight 0)) %)) maze))\n    (assoc-in [0 0] (assoc ((maze 0) 0) :visited 1 :weight 0))))\n\n;Generates a rectangular maze.\n(defn rectangle-maze\n  [row col]\n  (vec (take row (repeat (vec (take col (repeat cell)))))))\n\n(defn unvisited-cell?\n  [r c mask grid]\n  (let [cell (get-in grid [r c])\n        maskCell (get (get mask r) c)]\n    (and (= 0 (cell :visited))\n         (if (nil? maskCell) true (= 0 maskCell)))))\n\n(defn valid-unvisited-cell?\n  [r c mask grid]\n  (and\n    (&lt;= 0 r (dec (count grid)))\n    (&lt;= 0 c (dec (count (nth grid r))))\n    (unvisited-cell? r c mask grid)))\n\n(defn solver-valid-unvisited-cell?\n  [direction r c mask grid]\n  (and\n    (&lt;= 0 r (dec (count grid)))\n    (&lt;= 0 c (dec (count (nth grid r))))\n    (unvisited-cell? r c  mask grid)\n    (= 1 (get (get-in grid [r c]) (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))))\n    ))\n\n(defn solver-valid-lower-weight-cell?\n  [direction r c link-r link-c grid]\n  (and\n    (&lt;= 0 link-r (dec (count grid)))\n    (&lt;= 0 link-c (dec (count (nth grid link-r))))\n    (= 1 (get (get-in grid [link-r link-c]) (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))))\n    (if-not (nil? ((get-in grid [link-r link-c]) :weight)) (&lt; ((get-in grid [link-r link-c]) :weight) ((get-in grid [r c]) :weight)) false)\n    ))\n\n(defn reset-visited\n  [maze]\n  (into [] (map #(vec (map (fn [cell] (assoc cell :visited 1)) %)) maze)))\n\n(defn visit-cell\n  [r c grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :visited 1)))\n\n(defn join-cells\n  [cell1_r cell1_c cell2_r cell2_c direction grid]\n  (let [linkKey (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))]\n    (-&gt;\n      (assoc-in grid [cell1_r cell1_c] (assoc ((grid cell1_r) cell1_c) direction 1))\n      (assoc-in [cell2_r cell2_c] (assoc ((grid cell2_r) cell2_c) linkKey 1)))))\n\n(defn recursive-backtracking-maze\n  ([current_row current_col mask current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (if (valid-unvisited-cell? link-r link-c mask grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (join-cells current_row current_col link-r link-c direction)\n                   (recursive-backtracking-maze link-r link-c mask)) grid))) current_grid (shuffle [:north :east :south :west])))\n  ([mask maze] (recursive-backtracking-maze 0 0 mask (init-maze maze)))) ;start at a random point\n\n(defn addWeight\n  [r c weight grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :weight weight)))\n\n(defn dijkstras\n  ([current_row current_col mask current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (if (solver-valid-unvisited-cell? direction link-r link-c mask grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (addWeight link-r link-c (inc ((get-in grid [current_row current_col]) :weight)))\n                   (dijkstras link-r link-c mask)) grid))) current_grid (shuffle [:north :east :south :west]))\n   )\n  ([mask maze] (dijkstras 0 0 mask (init-maze-for-solving maze))))\n\n(defn addPath\n  [r c grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :path 1)))\n\n(defn find-route\n  [start-row start-col finish-row finish-col weighted-maze]\n  (loop [r finish-row c finish-col maze (init-maze-for-solving weighted-maze)]\n    (cond\n      (= 1 ((get-in maze [start-row start-col]) :path)) (reset-visited maze)\n      :else\n      (let [lowest-weight (first (filter #(solver-valid-lower-weight-cell? % r c (+ r (Direction_R %)) (+ c (Direction_C %)) maze) sides))\n            link-r (+ r (Direction_R lowest-weight))\n            link-c (+ c (Direction_C lowest-weight))]\n        (-&gt;&gt;\n          (addPath link-r link-c maze)\n          (recur link-r link-c))\n        ))))\n\n(defn make-maze [r c mask]\n  (recursive-backtracking-maze mask (rectangle-maze r c)))\n\n(defn get-drawn-maze\n  [state]\n  (let [maze (find-route 0 0 5 5 (dijkstras (state :mask) (make-maze (state :maze-size) (state :maze-size) (state :mask)))) margin 70]\n    (q/fill 0)\n    (q/background 240)\n    (q/line margin margin (- (state :width) margin) margin)\n    (let [y-cell-size (/ (- (state :height) (* 2 margin)) (count maze))\n          x-cell-size (/ (- (state :width) (* 2 margin)) (-&gt; maze first count))]\n      (dotimes [y (count maze)]\n        (let [yv (+ margin (* y y-cell-size))\n              yv2 (+ y-cell-size yv)]\n          (q/line margin yv margin yv2)\n          (dotimes [x (-&gt; maze first count)]\n            (let [xv (+ margin (* x x-cell-size))\n                  xv2 (+ x-cell-size xv)]\n              ;(if (= 0 ((mget x y maze) :south) (q/line xv yv2 xv2 yv2))\n              ;(if (not= 0 ((mget x y maze) :north))\n              ;  (when (= 0 ((mget x y maze) :east) (q/line xv yv2 xv2 yv2))\n              ;  (q/line xv2 yv xv2 yv2))))\n              (let [cell (get-in maze [y x])\n                    maskCell (get (get (state :mask) y) x)]\n                (if (or (nil? maskCell) (= 0 maskCell)) (if (= 0 (cell :visited))\n                                                          (do\n                                                            (q/fill 200 255 200)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))\n                                                          (do\n                                                            (q/fill (- 255 (cell :weight)) 50 100)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)))\n                                                        (do\n                                                          (q/fill 100 255 100)\n                                                          (q/no-stroke)\n                                                          (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)\n                                                          )\n                                                        )\n                (when (= 1 (cell :path))\n                  (do\n                    (q/fill 180 180 180)\n                    (q/no-stroke)\n                    (q/rect (+ xv (/ (/ x-cell-size 2) 2)) (+ yv (/ (/ y-cell-size 2) 2)) (/ x-cell-size 2) (/ y-cell-size 2))))\n\n                (q/stroke 0)\n                (q/stroke-weight 5)\n                (q/fill 0)\n                (when (= 0 (cell :east)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv2 yv xv2 yv2)))\n                (when (= 0 (cell :west)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv yv2)))\n                (when (= 0 (cell :south)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv2 xv2 yv2)))\n                (when (= 0 (cell :north)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv2 yv)))\n                (when (&gt; 14 (count maze)) (q/text-size 20))\n                (when (&gt; 14 (count maze)) (q/text (str (cell :weight)) (+ xv (/ x-cell-size 2)) (+ yv (/ y-cell-size 2))))))))))))\n\n\n(defn create-maze\n  \&quot;size: int (preferable up to 32 as the algorithm I have causes a stack overflow for now\n   mask: string (the 2d array of values where 1 will be the mask and 0 is ignored\&quot;\n  [size mask]\n  (let [*agnt* (agent {})]\n    (send-off *agnt* (fn [state]\n                       (q/sketch\n                         :draw (fn []\n                                 (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                                              (q/no-loop)\n                                              (get-drawn-maze {:maze-size size :mask (getImageArrayFromString mask) :width 750 :height 750})\n                                              )\n                                 (q/exit)\n\n                                 ))\n                       (assoc state :done true)))\n\n    (await *agnt*)\n    ))\n\n;(q/sketch\n;  :draw (fn []\n;          (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n;                       (q/no-loop)\n;                       (get-drawn-maze {:maze-size 64 :width 750 :height 750})\n;                       )\n;          (q/exit)\n;          ))&quot;, :offset 9605, :ns &quot;user&quot;} {:command &quot;(q/sketch\n  :draw (fn []\n          (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                       (q/no-loop)\n                       (get-drawn-maze {:maze-size 32 :width 750 :height 750})\n                       )\n          (q/exit)\n          ))&quot;, :offset 262, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(find-route 0 0 5 5 (dijkstras [[]] (make-maze 32 32 [[]])))&quot;, :offset 60, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(find-route 0 0 5 5 (dijkstras \&quot;\&quot; (make-maze 32 32 \&quot;\&quot;)))&quot;, :offset 56, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(find-route 0 0 5 5 (dijkstras [] (make-maze 32 32 [])))&quot;, :offset 56, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(dijkstras [] (make-maze 32 32 []))&quot;, :offset 35, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(defn solver-valid-lower-weight-cell?\n  [direction r c link-r link-c grid]\n  (and\n    (&lt;= 0 link-r (dec (count grid)))\n    (&lt;= 0 link-c (dec (count (nth grid link-r))))\n    (= 1 (get (get-in grid [link-r link-c]) (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))))\n    (if-not (nil? ((get-in grid [link-r link-c]) :weight)) (&lt; ((get-in grid [link-r link-c]) :weight) ((get-in grid [r c]) :weight)) false)\n    ))&quot;, :offset 421, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(find-route 0 0 2 2 (dijkstras [] (make-maze 4 4)))&quot;, :offset 51, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(get (get [] 2) 0)&quot;, :offset 18, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(getImageArrayFromString \&quot;\&quot;)&quot;, :offset 28, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(find-route 0 0 2 2 (dijkstras (make-maze 4 4)))&quot;, :offset 48, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(dijkstras [] (make-maze 4 4 []))&quot;, :offset 33, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(defn find-route\n  [start-row start-col finish-row finish-col weighted-maze]\n  (loop [r finish-row c finish-col maze (init-maze-for-solving weighted-maze)]\n    (println start-row start-col r c maze)\n    (cond\n      (= 1 ((get-in maze [start-row start-col]) :path)) (reset-visited maze)\n      :else\n      (let [lowest-weight (first (filter #(solver-valid-lower-weight-cell? % r c (+ r (Direction_R %)) (+ c (Direction_C %)) maze) sides))\n            link-r (+ r (Direction_R lowest-weight))\n            link-c (+ c (Direction_C lowest-weight))]\n        (-&gt;&gt;\n          (addPath link-r link-c maze)\n          (recur link-r link-c))\n        ))))&quot;, :offset 641, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(find-route 0 0 2 2 (dijkstras [] (make-maze 4 4 [])))&quot;, :offset 54, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(ns compojure-api-test.mazegenerator\n  (:require [quil.core :as q]\n            [quil.middleware :as m]\n            [clojure.string :as str]))\n\n(defn str-&gt;int [str]\n  (let [n (read-string str)]\n    (if (number? n) n nil)))\n\n(defn getImageArrayFromString\n  [mask]\n  (let [maskString mask]\n    (vec (map #(vec %) (partition 64 (mapv #(if (= 255 (str-&gt;int (first %))) 1 0) (partition 4 (str/split maskString #\&quot;,\&quot;))))))))\n\n(def cell {:north 0 :east 0 :south 0 :west 0 :visited 0})\n\n;The directions defs define how much to add or take away from the row and column values to go either way\n(def Direction_R {:north -1, :east 0, :south 1, :west 0})\n(def Direction_C {:north 0, :east 1, :south 0, :west -1})\n\n;This is just a helper array to map values to keywords\n(def sides [:north :east :south :west])\n(def sides_backtracker {:north 0 :east 1 :south 2 :west 3})\n\n;Set the cell at 0,0 to have been visited since we start there to generate the maze.\n(defn init-maze\n  [maze]\n  (assoc-in maze [0 0] (assoc ((maze 0) 0) :visited 1)))\n\n;To solve the maze, we use the weight keyword too so this is added to every cell and initialised at 0.\n(defn init-maze-for-solving\n  [maze]\n  (-&gt;\n    (into [] (map #(vec (map (fn [cell] (assoc cell :path 0 :visited 0)) %)) maze))))\n\n;Generates a rectangular maze.\n(defn rectangle-maze\n  [row col]\n  (vec (take row (repeat (vec (take col (repeat cell)))))))\n\n(defn unvisited-cell?\n  [r c mask grid]\n  (let [cell (get-in grid [r c])\n        maskCell (get (get mask r) c)]\n    (and (= 0 (cell :visited))\n         (if (nil? maskCell) true (= 0 maskCell)))))\n\n(defn valid-unvisited-cell?\n  [r c mask grid]\n  (and\n    (&lt;= 0 r (dec (count grid)))\n    (&lt;= 0 c (dec (count (nth grid r))))\n    (unvisited-cell? r c mask grid)))\n\n(defn solver-valid-unvisited-cell?\n  [direction r c mask grid]\n  (and\n    (&lt;= 0 r (dec (count grid)))\n    (&lt;= 0 c (dec (count (nth grid r))))\n    (unvisited-cell? r c mask grid)\n    (= 1 (get (get-in grid [r c]) (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))))\n    ))\n\n(defn solver-valid-lower-weight-cell?\n  [direction r c link-r link-c grid]\n  (and\n    (&lt;= 0 link-r (dec (count grid)))\n    (&lt;= 0 link-c (dec (count (nth grid link-r))))\n    (= 1 (get (get-in grid [link-r link-c]) (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))))\n    (if-not (nil? ((get-in grid [link-r link-c]) :weight)) (&lt; ((get-in grid [link-r link-c]) :weight) ((get-in grid [r c]) :weight)) false)\n    ))\n\n(defn reset-visited\n  [maze]\n  (into [] (map #(vec (map (fn [cell] (assoc cell :visited 1)) %)) maze)))\n\n(defn visit-cell\n  [r c grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :visited 1)))\n\n(defn join-cells\n  [cell1_r cell1_c cell2_r cell2_c direction grid]\n  (let [linkKey (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))]\n    (-&gt;\n      (assoc-in grid [cell1_r cell1_c] (assoc ((grid cell1_r) cell1_c) direction 1))\n      (assoc-in [cell2_r cell2_c] (assoc ((grid cell2_r) cell2_c) linkKey 1)))))\n\n(defn recursive-backtracking-maze\n  ([current_row current_col mask current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (if (valid-unvisited-cell? link-r link-c mask grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (join-cells current_row current_col link-r link-c direction)\n                   (recursive-backtracking-maze link-r link-c mask)) grid))) current_grid (shuffle [:north :east :south :west])))\n  ([mask maze] (recursive-backtracking-maze 0 0 mask (init-maze maze)))) ;start at a random point\n\n(defn addWeight\n  [r c weight grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :weight weight)))\n\n(defn dijkstras\n  ([current_row current_col mask current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (if (solver-valid-unvisited-cell? direction link-r link-c mask grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (addWeight link-r link-c (inc ((get-in grid [current_row current_col]) :weight)))\n                   (dijkstras link-r link-c mask)) grid))) current_grid (shuffle [:north :east :south :west]))\n   )\n  ([mask maze] (dijkstras 0 0 mask (init-maze-for-solving maze))))\n\n(defn addPath\n  [r c grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :path 1)))\n\n(defn find-route\n  [start-row start-col finish-row finish-col weighted-maze]\n  (loop [r finish-row c finish-col maze (init-maze-for-solving weighted-maze)]\n    (cond\n      (= 1 ((get-in maze [start-row start-col]) :path)) (reset-visited maze)\n      :else\n      (let [lowest-weight (first (filter #(solver-valid-lower-weight-cell? % r c (+ r (Direction_R %)) (+ c (Direction_C %)) maze) sides))\n            link-r (+ r (Direction_R lowest-weight))\n            link-c (+ c (Direction_C lowest-weight))]\n        (-&gt;&gt;\n          (addPath link-r link-c maze)\n          (recur link-r link-c))\n        ))))\n\n(defn make-maze [r c mask]\n  (recursive-backtracking-maze mask (rectangle-maze r c)))\n\n(defn get-drawn-maze\n  [state]\n  (let [maze (find-route 0 0 5 5 (dijkstras (state :mask) (make-maze (state :maze-size) (state :maze-size) (state :mask)))) margin 70]\n    (q/fill 0)\n    (q/background 240)\n    (q/line margin margin (- (state :width) margin) margin)\n    (let [y-cell-size (/ (- (state :height) (* 2 margin)) (count maze))\n          x-cell-size (/ (- (state :width) (* 2 margin)) (-&gt; maze first count))]\n      (dotimes [y (count maze)]\n        (let [yv (+ margin (* y y-cell-size))\n              yv2 (+ y-cell-size yv)]\n          (q/line margin yv margin yv2)\n          (dotimes [x (-&gt; maze first count)]\n            (let [xv (+ margin (* x x-cell-size))\n                  xv2 (+ x-cell-size xv)]\n              ;(if (= 0 ((mget x y maze) :south) (q/line xv yv2 xv2 yv2))\n              ;(if (not= 0 ((mget x y maze) :north))\n              ;  (when (= 0 ((mget x y maze) :east) (q/line xv yv2 xv2 yv2))\n              ;  (q/line xv2 yv xv2 yv2))))\n              (let [cell (get-in maze [y x])\n                    maskCell (get (get (state :mask) y) x)]\n                (if (or (nil? maskCell) (= 0 maskCell)) (if (= 0 (cell :visited))\n                                                          (do\n                                                            (q/fill 200 255 200)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))\n                                                          (do\n                                                            (q/fill (- 255 (cell :weight)) 50 100)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)))\n                                                        (do\n                                                          (q/fill 100 255 100)\n                                                          (q/no-stroke)\n                                                          (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)\n                                                          )\n                                                        )\n                (when (= 1 (cell :path))\n                  (do\n                    (q/fill 180 180 180)\n                    (q/no-stroke)\n                    (q/rect (+ xv (/ (/ x-cell-size 2) 2)) (+ yv (/ (/ y-cell-size 2) 2)) (/ x-cell-size 2) (/ y-cell-size 2))))\n\n                (q/stroke 0)\n                (q/stroke-weight 5)\n                (q/fill 0)\n                (when (= 0 (cell :east)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv2 yv xv2 yv2)))\n                (when (= 0 (cell :west)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv yv2)))\n                (when (= 0 (cell :south)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv2 xv2 yv2)))\n                (when (= 0 (cell :north)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv2 yv)))\n                (when (&gt; 14 (count maze)) (q/text-size 20))\n                (when (&gt; 14 (count maze)) (q/text (str (cell :weight)) (+ xv (/ x-cell-size 2)) (+ yv (/ y-cell-size 2))))))))))))\n\n\n(defn create-maze\n  \&quot;size: int (preferable up to 32 as the algorithm I have causes a stack overflow for now\n   mask: string (the 2d array of values where 1 will be the mask and 0 is ignored\&quot;\n  [size mask]\n  (let [*agnt* (agent {})]\n    (send-off *agnt* (fn [state]\n                       (q/sketch\n                         :draw (fn []\n                                 (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                                              (q/no-loop)\n                                              (get-drawn-maze {:maze-size size :mask (getImageArrayFromString mask) :width 750 :height 750})\n                                              )\n                                 (q/exit)\n\n                                 ))\n                       (assoc state :done true)))\n\n    (await *agnt*)\n    ))\n\n(q/sketch\n  :draw (fn []\n          (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                       (q/no-loop)\n                       (get-drawn-maze {:maze-size 32 :mask [] :width 750 :height 750})\n                       )\n          (q/exit)\n          ))&quot;, :offset 9540, :ns &quot;user&quot;} {:command &quot;(get-drawn-maze {:maze-size 32 :mask [[]] :width 750 :height 750})&quot;, :offset 66, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(get-drawn-maze {:maze-size 32 :mask \&quot;\&quot; :width 750 :height 750})&quot;, :offset 64, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(get-drawn-maze {:maze-size 32 :mask [] :width 750 :height 750})&quot;, :offset 64, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(dijkstras (state :mask) (make-maze (state :maze-size) (state :maze-size) (state :mask)))&quot;, :offset 89, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(make-maze 5 5 [])&quot;, :offset 18, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(defn dijkstras\n  ([current_row current_col mask current_grid]\n   (println current_row current_col mask current_grid)\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (if (solver-valid-unvisited-cell? direction link-r link-c mask grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (addWeight link-r link-c (inc ((get-in grid [current_row current_col]) :weight)))\n                   (dijkstras link-r link-c mask)) grid))) current_grid (shuffle [:north :east :south :west]))\n   )\n  ([mask maze] (dijkstras 0 0 mask (init-maze-for-solving maze))))&quot;, :offset 723, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(defn dijkstras\n  ([current_row current_col mask current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (println mask)\n               (if (solver-valid-unvisited-cell? direction link-r link-c mask grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (addWeight link-r link-c (inc ((get-in grid [current_row current_col]) :weight)))\n                   (dijkstras link-r link-c mask)) grid))) current_grid (shuffle [:north :east :south :west]))\n   )\n  ([mask maze] (dijkstras 0 0 mask (init-maze-for-solving maze))))&quot;, :offset 698, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(defn init-maze-for-dijkstas\n  [maze]\n  (-&gt;\n    (into [] (map #(vec (map (fn [cell] (assoc cell :visited 0 :weight 0)) %)) maze))\n    (assoc-in [0 0] (assoc ((maze 0) 0) :visited 1 :weight 0))))&quot;, :offset 194, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(defn dijkstras\n  ([current_row current_col mask current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (println mask)\n               (if (solver-valid-unvisited-cell? direction link-r link-c mask grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (addWeight link-r link-c (inc ((get-in grid [current_row current_col]) :weight)))\n                   (dijkstras link-r link-c mask)) grid))) current_grid (shuffle [:north :east :south :west]))\n   )\n  ([mask maze] (dijkstras 0 0 mask (init-maze-for-dijkstas maze))))&quot;, :offset 699, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(dijkstras [] (make-maze 5 5 []))&quot;, :offset 33, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(defn dijkstras\n  ([current_row current_col mask current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (if (solver-valid-unvisited-cell? direction link-r link-c mask grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (addWeight link-r link-c (inc ((get-in grid [current_row current_col]) :weight)))\n                   (dijkstras link-r link-c mask)) grid))) current_grid (shuffle [:north :east :south :west]))\n   )\n  ([mask maze] (dijkstras 0 0 mask (init-maze-for-dijkstas maze))))&quot;, :offset 669, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(find-route 0 0 5 5 (dijkstras [] (make-maze 10 10 [])))&quot;, :offset 56, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(ns compojure-api-test.mazegenerator\n  (:require [quil.core :as q]\n            [quil.middleware :as m]\n            [clojure.string :as str]))\n\n(defn str-&gt;int [str]\n  (let [n (read-string str)]\n    (if (number? n) n nil)))\n\n(defn getImageArrayFromString\n  [mask]\n  (let [maskString mask]\n    (vec (map #(vec %) (partition 64 (mapv #(if (= 255 (str-&gt;int (first %))) 1 0) (partition 4 (str/split maskString #\&quot;,\&quot;))))))))\n\n(def cell {:north 0 :east 0 :south 0 :west 0 :visited 0})\n\n;The directions defs define how much to add or take away from the row and column values to go either way\n(def Direction_R {:north -1, :east 0, :south 1, :west 0})\n(def Direction_C {:north 0, :east 1, :south 0, :west -1})\n\n;This is just a helper array to map values to keywords\n(def sides [:north :east :south :west])\n(def sides_backtracker {:north 0 :east 1 :south 2 :west 3})\n\n;Set the cell at 0,0 to have been visited since we start there to generate the maze.\n(defn init-maze\n  [maze]\n  (assoc-in maze [0 0] (assoc ((maze 0) 0) :visited 1)))\n\n(defn init-maze-for-dijkstas\n  [maze]\n  (-&gt;\n    (into [] (map #(vec (map (fn [cell] (assoc cell :visited 0 :weight 0)) %)) maze))\n    (assoc-in [0 0] (assoc ((maze 0) 0) :visited 1 :weight 0))))\n\n(defn init-maze-for-solving\n  [maze]\n  (-&gt;\n    (into [] (map #(vec (map (fn [cell] (assoc cell :path 0 :visited 0)) %)) maze))))\n\n;Generates a rectangular maze.\n(defn rectangle-maze\n  [row col]\n  (vec (take row (repeat (vec (take col (repeat cell)))))))\n\n(defn unvisited-cell?\n  [r c mask grid]\n  (let [cell (get-in grid [r c])\n        maskCell (get (get mask r) c)]\n    (and (= 0 (cell :visited))\n         (if (nil? maskCell) true (= 0 maskCell)))))\n\n(defn valid-unvisited-cell?\n  [r c mask grid]\n  (and\n    (&lt;= 0 r (dec (count grid)))\n    (&lt;= 0 c (dec (count (nth grid r))))\n    (unvisited-cell? r c mask grid)))\n\n(defn solver-valid-unvisited-cell?\n  [direction r c mask grid]\n  (and\n    (&lt;= 0 r (dec (count grid)))\n    (&lt;= 0 c (dec (count (nth grid r))))\n    (unvisited-cell? r c mask grid)\n    (= 1 (get (get-in grid [r c]) (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))))\n    ))\n\n(defn solver-valid-lower-weight-cell?\n  [direction r c link-r link-c grid]\n  (and\n    (&lt;= 0 link-r (dec (count grid)))\n    (&lt;= 0 link-c (dec (count (nth grid link-r))))\n    (= 1 (get (get-in grid [link-r link-c]) (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))))\n    (if-not (nil? ((get-in grid [link-r link-c]) :weight)) (&lt; ((get-in grid [link-r link-c]) :weight) ((get-in grid [r c]) :weight)) false)\n    ))\n\n(defn reset-visited\n  [maze]\n  (into [] (map #(vec (map (fn [cell] (assoc cell :visited 1)) %)) maze)))\n\n(defn visit-cell\n  [r c grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :visited 1)))\n\n(defn join-cells\n  [cell1_r cell1_c cell2_r cell2_c direction grid]\n  (let [linkKey (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))]\n    (-&gt;\n      (assoc-in grid [cell1_r cell1_c] (assoc ((grid cell1_r) cell1_c) direction 1))\n      (assoc-in [cell2_r cell2_c] (assoc ((grid cell2_r) cell2_c) linkKey 1)))))\n\n(defn recursive-backtracking-maze\n  ([current_row current_col mask current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (if (valid-unvisited-cell? link-r link-c mask grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (join-cells current_row current_col link-r link-c direction)\n                   (recursive-backtracking-maze link-r link-c mask)) grid))) current_grid (shuffle [:north :east :south :west])))\n  ([mask maze] (recursive-backtracking-maze 0 0 mask (init-maze maze)))) ;start at a random point\n\n(defn addWeight\n  [r c weight grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :weight weight)))\n\n(defn dijkstras\n  ([current_row current_col mask current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (if (solver-valid-unvisited-cell? direction link-r link-c mask grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (addWeight link-r link-c (inc ((get-in grid [current_row current_col]) :weight)))\n                   (dijkstras link-r link-c mask)) grid))) current_grid (shuffle [:north :east :south :west]))\n   )\n  ([mask maze] (dijkstras 0 0 mask (init-maze-for-dijkstas maze))))\n\n(defn addPath\n  [r c grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :path 1)))\n\n(defn find-route\n  [start-row start-col finish-row finish-col weighted-maze]\n  (loop [r finish-row c finish-col maze (init-maze-for-solving weighted-maze)]\n    (cond\n      (= 1 ((get-in maze [start-row start-col]) :path)) (reset-visited maze)\n      :else\n      (let [lowest-weight (first (filter #(solver-valid-lower-weight-cell? % r c (+ r (Direction_R %)) (+ c (Direction_C %)) maze) sides))\n            link-r (+ r (Direction_R lowest-weight))\n            link-c (+ c (Direction_C lowest-weight))]\n        (-&gt;&gt;\n          (addPath link-r link-c maze)\n          (recur link-r link-c))\n        ))))\n\n(defn make-maze [r c mask]\n  (recursive-backtracking-maze mask (rectangle-maze r c)))\n\n(defn get-drawn-maze\n  [state]\n  (let [maze (find-route 0 0 5 5 (dijkstras (state :mask) (make-maze (state :maze-size) (state :maze-size) (state :mask)))) margin 70]\n    (q/fill 0)\n    (q/background 240)\n    (q/line margin margin (- (state :width) margin) margin)\n    (let [y-cell-size (/ (- (state :height) (* 2 margin)) (count maze))\n          x-cell-size (/ (- (state :width) (* 2 margin)) (-&gt; maze first count))]\n      (dotimes [y (count maze)]\n        (let [yv (+ margin (* y y-cell-size))\n              yv2 (+ y-cell-size yv)]\n          (q/line margin yv margin yv2)\n          (dotimes [x (-&gt; maze first count)]\n            (let [xv (+ margin (* x x-cell-size))\n                  xv2 (+ x-cell-size xv)]\n              ;(if (= 0 ((mget x y maze) :south) (q/line xv yv2 xv2 yv2))\n              ;(if (not= 0 ((mget x y maze) :north))\n              ;  (when (= 0 ((mget x y maze) :east) (q/line xv yv2 xv2 yv2))\n              ;  (q/line xv2 yv xv2 yv2))))\n              (let [cell (get-in maze [y x])\n                    maskCell (get (get (state :mask) y) x)]\n                (if (or (nil? maskCell) (= 0 maskCell)) (if (= 0 (cell :visited))\n                                                          (do\n                                                            (q/fill 200 255 200)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))\n                                                          (do\n                                                            (q/fill (- 255 (cell :weight)) 50 100)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)))\n                                                        (do\n                                                          (q/fill 100 255 100)\n                                                          (q/no-stroke)\n                                                          (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)\n                                                          )\n                                                        )\n                (when (= 1 (cell :path))\n                  (do\n                    (q/fill 180 180 180)\n                    (q/no-stroke)\n                    (q/rect (+ xv (/ (/ x-cell-size 2) 2)) (+ yv (/ (/ y-cell-size 2) 2)) (/ x-cell-size 2) (/ y-cell-size 2))))\n\n                (q/stroke 0)\n                (q/stroke-weight 5)\n                (q/fill 0)\n                (when (= 0 (cell :east)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv2 yv xv2 yv2)))\n                (when (= 0 (cell :west)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv yv2)))\n                (when (= 0 (cell :south)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv2 xv2 yv2)))\n                (when (= 0 (cell :north)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv2 yv)))\n                (when (&gt; 14 (count maze)) (q/text-size 20))\n                (when (&gt; 14 (count maze)) (q/text (str (cell :weight)) (+ xv (/ x-cell-size 2)) (+ yv (/ y-cell-size 2))))))))))))\n\n\n(defn create-maze\n  \&quot;size: int (preferable up to 32 as the algorithm I have causes a stack overflow for now\n   mask: string (the 2d array of values where 1 will be the mask and 0 is ignored\&quot;\n  [size mask]\n  (let [*agnt* (agent {})]\n    (send-off *agnt* (fn [state]\n                       (q/sketch\n                         :draw (fn []\n                                 (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                                              (q/no-loop)\n                                              (get-drawn-maze {:maze-size size :mask (getImageArrayFromString mask) :width 750 :height 750})\n                                              )\n                                 (q/exit)\n\n                                 ))\n                       (assoc state :done true)))\n\n    (await *agnt*)\n    ))\n\n;(q/sketch\n;  :draw (fn []\n;          (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n;                       (q/no-loop)\n;                       (get-drawn-maze {:maze-size 32 :mask [] :width 750 :height 750})\n;                       )\n;          (q/exit)\n;          ))&quot;, :offset 9642, :ns &quot;user&quot;} {:command &quot;(defn get-drawn-maze\n  [state]\n  (let [maze (find-route 0 0 5 5 (dijkstras (state :mask) (make-maze (state :maze-size) (state :maze-size) (state :mask)))) margin 70]\n    (q/fill 0)\n    (q/background 240)\n    (q/line margin margin (- (state :width) margin) margin)\n    (let [y-cell-size (/ (- (state :height) (* 2 margin)) (count maze))\n          x-cell-size (/ (- (state :width) (* 2 margin)) (-&gt; maze first count))]\n      (dotimes [y (count maze)]\n        (let [yv (+ margin (* y y-cell-size))\n              yv2 (+ y-cell-size yv)]\n          (q/line margin yv margin yv2)\n          (dotimes [x (-&gt; maze first count)]\n            (let [xv (+ margin (* x x-cell-size))\n                  xv2 (+ x-cell-size xv)]\n              ;(if (= 0 ((mget x y maze) :south) (q/line xv yv2 xv2 yv2))\n              ;(if (not= 0 ((mget x y maze) :north))\n              ;  (when (= 0 ((mget x y maze) :east) (q/line xv yv2 xv2 yv2))\n              ;  (q/line xv2 yv xv2 yv2))))\n              (let [cell (get-in maze [y x])\n                    maskCell (get (get (state :mask) y) x)]\n                (if (or (nil? maskCell) (= 0 maskCell)) (if (= 0 (cell :visited))\n                                                          (do\n                                                            (q/fill 200 255 200)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))\n                                                          (do\n                                                            (q/fill (- 255 (cell :weight)) 50 100)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)))\n                                                        (do\n                                                          (q/fill 100 255 100)\n                                                          (q/no-stroke)\n                                                          (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)\n                                                          )\n                                                        )\n                (when (= 1 (cell :path))\n                  (do\n                    (q/fill 0 255 255)\n                    (q/no-stroke)\n                    (q/rect (+ xv (/ (/ x-cell-size 2) 2)) (+ yv (/ (/ y-cell-size 2) 2)) (/ x-cell-size 2) (/ y-cell-size 2))))\n\n                (q/stroke 0)\n                (q/stroke-weight 5)\n                (q/fill 0)\n                (when (= 0 (cell :east)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv2 yv xv2 yv2)))\n                (when (= 0 (cell :west)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv yv2)))\n                (when (= 0 (cell :south)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv2 xv2 yv2)))\n                (when (= 0 (cell :north)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv2 yv)))\n                (when (&gt; 14 (count maze)) (q/text-size 20))\n                (when (&gt; 14 (count maze)) (q/text (str (cell :weight)) (+ xv (/ x-cell-size 2)) (+ yv (/ y-cell-size 2))))))))))))&quot;, :offset 3242, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(defn get-drawn-maze\n  [state]\n  (let [maze (find-route 0 0 5 5 (dijkstras (state :mask) (make-maze (state :maze-size) (state :maze-size) (state :mask)))) margin 70]\n    (q/fill 0)\n    (q/background 240)\n    (q/line margin margin (- (state :width) margin) margin)\n    (let [y-cell-size (/ (- (state :height) (* 2 margin)) (count maze))\n          x-cell-size (/ (- (state :width) (* 2 margin)) (-&gt; maze first count))]\n      (dotimes [y (count maze)]\n        (let [yv (+ margin (* y y-cell-size))\n              yv2 (+ y-cell-size yv)]\n          (q/line margin yv margin yv2)\n          (dotimes [x (-&gt; maze first count)]\n            (let [xv (+ margin (* x x-cell-size))\n                  xv2 (+ x-cell-size xv)]\n              ;(if (= 0 ((mget x y maze) :south) (q/line xv yv2 xv2 yv2))\n              ;(if (not= 0 ((mget x y maze) :north))\n              ;  (when (= 0 ((mget x y maze) :east) (q/line xv yv2 xv2 yv2))\n              ;  (q/line xv2 yv xv2 yv2))))\n              (let [cell (get-in maze [y x])\n                    maskCell (get (get (state :mask) y) x)]\n                (if (or (nil? maskCell) (= 0 maskCell)) (if (= 0 (cell :visited))\n                                                          (do\n                                                            (q/fill 200 255 200)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))\n                                                          (do\n                                                            (q/fill (- 255 (cell :weight)) 50 100)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)))\n                                                        (do\n                                                          (q/fill 100 255 100)\n                                                          (q/no-stroke)\n                                                          (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)\n                                                          )\n                                                        )\n                (when (= 1 (cell :path))\n                  (do\n                    (q/fill 255 255 0)\n                    (q/no-stroke)\n                    (q/rect (+ xv (/ (/ x-cell-size 2) 2)) (+ yv (/ (/ y-cell-size 2) 2)) (/ x-cell-size 2) (/ y-cell-size 2))))\n\n                (q/stroke 0)\n                (q/stroke-weight 5)\n                (q/fill 0)\n                (when (= 0 (cell :east)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv2 yv xv2 yv2)))\n                (when (= 0 (cell :west)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv yv2)))\n                (when (= 0 (cell :south)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv2 xv2 yv2)))\n                (when (= 0 (cell :north)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv2 yv)))\n                (when (&gt; 14 (count maze)) (q/text-size 20))\n                (when (&gt; 14 (count maze)) (q/text (str (cell :weight)) (+ xv (/ x-cell-size 2)) (+ yv (/ y-cell-size 2))))))))))))&quot;, :offset 3242, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(defn get-drawn-maze\n  [state]\n  (let [maze (find-route 0 0 5 5 (dijkstras (state :mask) (make-maze (state :maze-size) (state :maze-size) (state :mask)))) margin 70]\n    (q/fill 0)\n    (q/background 240)\n    (q/line margin margin (- (state :width) margin) margin)\n    (let [y-cell-size (/ (- (state :height) (* 2 margin)) (count maze))\n          x-cell-size (/ (- (state :width) (* 2 margin)) (-&gt; maze first count))]\n      (dotimes [y (count maze)]\n        (let [yv (+ margin (* y y-cell-size))\n              yv2 (+ y-cell-size yv)]\n          (q/line margin yv margin yv2)\n          (dotimes [x (-&gt; maze first count)]\n            (let [xv (+ margin (* x x-cell-size))\n                  xv2 (+ x-cell-size xv)]\n              ;(if (= 0 ((mget x y maze) :south) (q/line xv yv2 xv2 yv2))\n              ;(if (not= 0 ((mget x y maze) :north))\n              ;  (when (= 0 ((mget x y maze) :east) (q/line xv yv2 xv2 yv2))\n              ;  (q/line xv2 yv xv2 yv2))))\n              (let [cell (get-in maze [y x])\n                    maskCell (get (get (state :mask) y) x)]\n                (if (or (nil? maskCell) (= 0 maskCell)) (if (= 0 (cell :visited))\n                                                          (do\n                                                            (q/fill 200 255 200)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))\n                                                          (do\n                                                            (q/fill (- 255 (cell :weight)) 50 100)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)))\n                                                        (do\n                                                          (q/fill 100 255 100)\n                                                          (q/no-stroke)\n                                                          (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)\n                                                          )\n                                                        )\n                (when (= 1 (cell :path))\n                  (do\n                    (q/fill 200 240 0)\n                    (q/no-stroke)\n                    (q/rect (+ xv (/ (/ x-cell-size 2) 2)) (+ yv (/ (/ y-cell-size 2) 2)) (/ x-cell-size 2) (/ y-cell-size 2))))\n\n                (q/image \&quot;mouse.jpg\&quot; xv yv x-cell-size y-cell-size)\n                (q/stroke 0)\n                (q/stroke-weight 5)\n                (q/fill 0)\n                (when (= 0 (cell :east)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv2 yv xv2 yv2)))\n                (when (= 0 (cell :west)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv yv2)))\n                (when (= 0 (cell :south)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv2 xv2 yv2)))\n                (when (= 0 (cell :north)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv2 yv)))\n                (when (&gt; 14 (count maze)) (q/text-size 20))\n                (when (&gt; 14 (count maze)) (q/text (str (cell :weight)) (+ xv (/ x-cell-size 2)) (+ yv (/ y-cell-size 2))))))))))))&quot;, :offset 3310, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(ns compojure-api-test.mazegenerator\n  (:require [quil.core :as q]\n            [quil.middleware :as m]\n            [clojure.string :as str]))\n\n(defn str-&gt;int [str]\n  (let [n (read-string str)]\n    (if (number? n) n nil)))\n\n(defn getImageArrayFromString\n  [mask]\n  (let [maskString mask]\n    (vec (map #(vec %) (partition 64 (mapv #(if (= 255 (str-&gt;int (first %))) 1 0) (partition 4 (str/split maskString #\&quot;,\&quot;))))))))\n\n(def cell {:north 0 :east 0 :south 0 :west 0 :visited 0})\n\n;The directions defs define how much to add or take away from the row and column values to go either way\n(def Direction_R {:north -1, :east 0, :south 1, :west 0})\n(def Direction_C {:north 0, :east 1, :south 0, :west -1})\n\n;This is just a helper array to map values to keywords\n(def sides [:north :east :south :west])\n(def sides_backtracker {:north 0 :east 1 :south 2 :west 3})\n\n;Set the cell at 0,0 to have been visited since we start there to generate the maze.\n(defn init-maze\n  [maze]\n  (assoc-in maze [0 0] (assoc ((maze 0) 0) :visited 1)))\n\n(defn init-maze-for-dijkstas\n  [maze]\n  (-&gt;\n    (into [] (map #(vec (map (fn [cell] (assoc cell :visited 0 :weight 0)) %)) maze))\n    (assoc-in [0 0] (assoc ((maze 0) 0) :visited 1 :weight 0))))\n\n(defn init-maze-for-solving\n  [maze]\n  (-&gt;\n    (into [] (map #(vec (map (fn [cell] (assoc cell :path 0 :visited 0)) %)) maze))))\n\n;Generates a rectangular maze.\n(defn rectangle-maze\n  [row col]\n  (vec (take row (repeat (vec (take col (repeat cell)))))))\n\n(defn unvisited-cell?\n  [r c mask grid]\n  (let [cell (get-in grid [r c])\n        maskCell (get (get mask r) c)]\n    (and (= 0 (cell :visited))\n         (if (nil? maskCell) true (= 0 maskCell)))))\n\n(defn valid-unvisited-cell?\n  [r c mask grid]\n  (and\n    (&lt;= 0 r (dec (count grid)))\n    (&lt;= 0 c (dec (count (nth grid r))))\n    (unvisited-cell? r c mask grid)))\n\n(defn solver-valid-unvisited-cell?\n  [direction r c mask grid]\n  (and\n    (&lt;= 0 r (dec (count grid)))\n    (&lt;= 0 c (dec (count (nth grid r))))\n    (unvisited-cell? r c mask grid)\n    (= 1 (get (get-in grid [r c]) (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))))\n    ))\n\n(defn solver-valid-lower-weight-cell?\n  [direction r c link-r link-c grid]\n  (and\n    (&lt;= 0 link-r (dec (count grid)))\n    (&lt;= 0 link-c (dec (count (nth grid link-r))))\n    (= 1 (get (get-in grid [link-r link-c]) (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))))\n    (if-not (nil? ((get-in grid [link-r link-c]) :weight)) (&lt; ((get-in grid [link-r link-c]) :weight) ((get-in grid [r c]) :weight)) false)\n    ))\n\n(defn reset-visited\n  [maze]\n  (into [] (map #(vec (map (fn [cell] (assoc cell :visited 1)) %)) maze)))\n\n(defn visit-cell\n  [r c grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :visited 1)))\n\n(defn join-cells\n  [cell1_r cell1_c cell2_r cell2_c direction grid]\n  (let [linkKey (nth sides (mod (+ 2 (get sides_backtracker direction)) 4))]\n    (-&gt;\n      (assoc-in grid [cell1_r cell1_c] (assoc ((grid cell1_r) cell1_c) direction 1))\n      (assoc-in [cell2_r cell2_c] (assoc ((grid cell2_r) cell2_c) linkKey 1)))))\n\n(defn recursive-backtracking-maze\n  ([current_row current_col mask current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (if (valid-unvisited-cell? link-r link-c mask grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (join-cells current_row current_col link-r link-c direction)\n                   (recursive-backtracking-maze link-r link-c mask)) grid))) current_grid (shuffle [:north :east :south :west])))\n  ([mask maze] (recursive-backtracking-maze 0 0 mask (init-maze maze)))) ;start at a random point\n\n(defn addWeight\n  [r c weight grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :weight weight)))\n\n(defn dijkstras\n  ([current_row current_col mask current_grid]\n   (reduce (fn [grid direction]\n             (let [link-r (+ current_row (Direction_R direction))\n                   link-c (+ current_col (Direction_C direction))]\n               (if (solver-valid-unvisited-cell? direction link-r link-c mask grid)\n                 (-&gt;&gt;\n                   (visit-cell link-r link-c grid)\n                   (addWeight link-r link-c (inc ((get-in grid [current_row current_col]) :weight)))\n                   (dijkstras link-r link-c mask)) grid))) current_grid (shuffle [:north :east :south :west]))\n   )\n  ([mask maze] (dijkstras 0 0 mask (init-maze-for-dijkstas maze))))\n\n(defn addPath\n  [r c grid]\n  (assoc-in grid [r c] (assoc ((grid r) c) :path 1)))\n\n(defn find-route\n  [start-row start-col finish-row finish-col weighted-maze]\n  (loop [r finish-row c finish-col maze (init-maze-for-solving weighted-maze)]\n    (cond\n      (= 1 ((get-in maze [start-row start-col]) :path)) (reset-visited maze)\n      :else\n      (let [lowest-weight (first (filter #(solver-valid-lower-weight-cell? % r c (+ r (Direction_R %)) (+ c (Direction_C %)) maze) sides))\n            link-r (+ r (Direction_R lowest-weight))\n            link-c (+ c (Direction_C lowest-weight))]\n        (-&gt;&gt;\n          (addPath link-r link-c maze)\n          (recur link-r link-c))\n        ))))\n\n(defn make-maze [r c mask]\n  (recursive-backtracking-maze mask (rectangle-maze r c)))\n\n(defn get-drawn-maze\n  [state]\n  (let [maze (find-route 0 0 5 5 (dijkstras (state :mask) (make-maze (state :maze-size) (state :maze-size) (state :mask)))) margin 70]\n    (q/fill 0)\n    (q/background 240)\n    (q/line margin margin (- (state :width) margin) margin)\n    (let [y-cell-size (/ (- (state :height) (* 2 margin)) (count maze))\n          x-cell-size (/ (- (state :width) (* 2 margin)) (-&gt; maze first count))]\n      (dotimes [y (count maze)]\n        (let [yv (+ margin (* y y-cell-size))\n              yv2 (+ y-cell-size yv)]\n          (q/line margin yv margin yv2)\n          (dotimes [x (-&gt; maze first count)]\n            (let [xv (+ margin (* x x-cell-size))\n                  xv2 (+ x-cell-size xv)]\n              ;(if (= 0 ((mget x y maze) :south) (q/line xv yv2 xv2 yv2))\n              ;(if (not= 0 ((mget x y maze) :north))\n              ;  (when (= 0 ((mget x y maze) :east) (q/line xv yv2 xv2 yv2))\n              ;  (q/line xv2 yv xv2 yv2))))\n              (let [cell (get-in maze [y x])\n                    maskCell (get (get (state :mask) y) x)]\n                (if (or (nil? maskCell) (= 0 maskCell)) (if (= 0 (cell :visited))\n                                                          (do\n                                                            (q/fill 200 255 200)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))\n                                                          (do\n                                                            (q/fill (- 255 (cell :weight)) 50 100)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)))\n                                                        (do\n                                                          (q/fill 100 255 100)\n                                                          (q/no-stroke)\n                                                          (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)\n                                                          )\n                                                        )\n                (when (= 1 (cell :path))\n                  (do\n                    (q/fill 200 240 0)\n                    (q/no-stroke)\n                    (q/rect (+ xv (/ (/ x-cell-size 2) 2)) (+ yv (/ (/ y-cell-size 2) 2)) (/ x-cell-size 2) (/ y-cell-size 2))))\n\n                (q/image \&quot;mouse.jpg\&quot; xv yv x-cell-size y-cell-size)\n                (q/stroke 0)\n                (q/stroke-weight 5)\n                (q/fill 0)\n                (when (= 0 (cell :east)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv2 yv xv2 yv2)))\n                (when (= 0 (cell :west)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv yv2)))\n                (when (= 0 (cell :south)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv2 xv2 yv2)))\n                (when (= 0 (cell :north)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv2 yv)))\n                (when (&gt; 14 (count maze)) (q/text-size 20))\n                (when (&gt; 14 (count maze)) (q/text (str (cell :weight)) (+ xv (/ x-cell-size 2)) (+ yv (/ y-cell-size 2))))))))))))\n\n\n(defn create-maze\n  \&quot;size: int (preferable up to 32 as the algorithm I have causes a stack overflow for now\n   mask: string (the 2d array of values where 1 will be the mask and 0 is ignored\&quot;\n  [size mask]\n  (let [*agnt* (agent {})]\n    (send-off *agnt* (fn [state]\n                       (q/sketch\n                         :draw (fn []\n                                 (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                                              (q/no-loop)\n                                              (get-drawn-maze {:maze-size size :mask (getImageArrayFromString mask) :width 750 :height 750})\n                                              )\n                                 (q/exit)\n\n                                 ))\n                       (assoc state :done true)))\n\n    (await *agnt*)\n    ))\n\n(q/sketch\n  :draw (fn []\n          (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                       (q/no-loop)\n                       (get-drawn-maze {:maze-size 32 :mask [] :width 750 :height 750})\n                       )\n          (q/exit)\n          ))&quot;, :offset 9700, :ns &quot;user&quot;} {:command &quot;(defn get-drawn-maze\n  [state]\n  (let [maze (find-route 0 0 5 5 (dijkstras (state :mask) (make-maze (state :maze-size) (state :maze-size) (state :mask)))) margin 70]\n    (q/fill 0)\n    (q/background 240)\n    (q/line margin margin (- (state :width) margin) margin)\n    (let [y-cell-size (/ (- (state :height) (* 2 margin)) (count maze))\n          x-cell-size (/ (- (state :width) (* 2 margin)) (-&gt; maze first count))]\n      (dotimes [y (count maze)]\n        (let [yv (+ margin (* y y-cell-size))\n              yv2 (+ y-cell-size yv)]\n          (q/line margin yv margin yv2)\n          (dotimes [x (-&gt; maze first count)]\n            (let [xv (+ margin (* x x-cell-size))\n                  xv2 (+ x-cell-size xv)]\n              ;(if (= 0 ((mget x y maze) :south) (q/line xv yv2 xv2 yv2))\n              ;(if (not= 0 ((mget x y maze) :north))\n              ;  (when (= 0 ((mget x y maze) :east) (q/line xv yv2 xv2 yv2))\n              ;  (q/line xv2 yv xv2 yv2))))\n              (let [cell (get-in maze [y x])\n                    maskCell (get (get (state :mask) y) x)]\n                (if (or (nil? maskCell) (= 0 maskCell)) (if (= 0 (cell :visited))\n                                                          (do\n                                                            (q/fill 200 255 200)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))\n                                                          (do\n                                                            (q/fill (- 255 (cell :weight)) 50 100)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)))\n                                                        (do\n                                                          (q/fill 100 255 100)\n                                                          (q/no-stroke)\n                                                          (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)\n                                                          )\n                                                        )\n                (when (= 1 (cell :path))\n                  (do\n                    (q/fill 200 240 0)\n                    (q/no-stroke)\n                    (q/rect (+ xv (/ (/ x-cell-size 2) 2)) (+ yv (/ (/ y-cell-size 2) 2)) (/ x-cell-size 2) (/ y-cell-size 2))))\n\n                (q/image (q/load-image \&quot;mouse.jpg\&quot;) xv yv x-cell-size y-cell-size)\n                (q/stroke 0)\n                (q/stroke-weight 5)\n                (q/fill 0)\n                (when (= 0 (cell :east)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv2 yv xv2 yv2)))\n                (when (= 0 (cell :west)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv yv2)))\n                (when (= 0 (cell :south)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv2 xv2 yv2)))\n                (when (= 0 (cell :north)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv2 yv)))\n                (when (&gt; 14 (count maze)) (q/text-size 20))\n                (when (&gt; 14 (count maze)) (q/text (str (cell :weight)) (+ xv (/ x-cell-size 2)) (+ yv (/ y-cell-size 2))))))))))))&quot;, :offset 3325, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(defn get-drawn-maze\n  [state]\n  (let [maze (find-route 0 0 5 5 (dijkstras (state :mask) (make-maze (state :maze-size) (state :maze-size) (state :mask)))) margin 70]\n    (q/fill 0)\n    (q/background 240)\n    (q/line margin margin (- (state :width) margin) margin)\n    (let [y-cell-size (/ (- (state :height) (* 2 margin)) (count maze))\n          x-cell-size (/ (- (state :width) (* 2 margin)) (-&gt; maze first count))]\n      (dotimes [y (count maze)]\n        (let [yv (+ margin (* y y-cell-size))\n              yv2 (+ y-cell-size yv)]\n          (q/line margin yv margin yv2)\n          (dotimes [x (-&gt; maze first count)]\n            (let [xv (+ margin (* x x-cell-size))\n                  xv2 (+ x-cell-size xv)]\n              ;(if (= 0 ((mget x y maze) :south) (q/line xv yv2 xv2 yv2))\n              ;(if (not= 0 ((mget x y maze) :north))\n              ;  (when (= 0 ((mget x y maze) :east) (q/line xv yv2 xv2 yv2))\n              ;  (q/line xv2 yv xv2 yv2))))\n              (let [cell (get-in maze [y x])\n                    maskCell (get (get (state :mask) y) x)]\n                (if (or (nil? maskCell) (= 0 maskCell)) (if (= 0 (cell :visited))\n                                                          (do\n                                                            (q/fill 200 255 200)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))\n                                                          (do\n                                                            (q/fill (- 255 (cell :weight)) 50 100)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)))\n                                                        (do\n                                                          (q/fill 100 255 100)\n                                                          (q/no-stroke)\n                                                          (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)\n                                                          )\n                                                        )\n                (when (= 1 (cell :path))\n                  (do\n                    (q/fill 200 240 0)\n                    (q/no-stroke)\n                    (q/rect (+ xv (/ (/ x-cell-size 2) 2)) (+ yv (/ (/ y-cell-size 2) 2)) (/ x-cell-size 2) (/ y-cell-size 2))))\n\n                (q/image (q/load-image \&quot;https://i.pinimg.com/originals/8b/61/59/8b6159362d0c7f115cc4d6bbb2477f75.jpg\&quot;) xv yv x-cell-size y-cell-size)\n                (q/stroke 0)\n                (q/stroke-weight 5)\n                (q/fill 0)\n                (when (= 0 (cell :east)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv2 yv xv2 yv2)))\n                (when (= 0 (cell :west)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv yv2)))\n                (when (= 0 (cell :south)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv2 xv2 yv2)))\n                (when (= 0 (cell :north)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv2 yv)))\n                (when (&gt; 14 (count maze)) (q/text-size 20))\n                (when (&gt; 14 (count maze)) (q/text (str (cell :weight)) (+ xv (/ x-cell-size 2)) (+ yv (/ y-cell-size 2))))))))))))&quot;, :offset 3392, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(defn get-drawn-maze\n  [state]\n  (let [maze (find-route 0 0 5 5 (dijkstras (state :mask) (make-maze (state :maze-size) (state :maze-size) (state :mask)))) margin 70]\n    (q/fill 0)\n    (q/background 240)\n    (q/line margin margin (- (state :width) margin) margin)\n    (let [y-cell-size (/ (- (state :height) (* 2 margin)) (count maze))\n          x-cell-size (/ (- (state :width) (* 2 margin)) (-&gt; maze first count))]\n      (dotimes [y (count maze)]\n        (let [yv (+ margin (* y y-cell-size))\n              yv2 (+ y-cell-size yv)]\n          (q/line margin yv margin yv2)\n          (dotimes [x (-&gt; maze first count)]\n            (let [xv (+ margin (* x x-cell-size))\n                  xv2 (+ x-cell-size xv)]\n              ;(if (= 0 ((mget x y maze) :south) (q/line xv yv2 xv2 yv2))\n              ;(if (not= 0 ((mget x y maze) :north))\n              ;  (when (= 0 ((mget x y maze) :east) (q/line xv yv2 xv2 yv2))\n              ;  (q/line xv2 yv xv2 yv2))))\n              (let [cell (get-in maze [y x])\n                    maskCell (get (get (state :mask) y) x)]\n                (if (or (nil? maskCell) (= 0 maskCell)) (if (= 0 (cell :visited))\n                                                          (do\n                                                            (q/fill 200 255 200)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))\n                                                          (do\n                                                            (q/fill (- 255 (cell :weight)) 50 100)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)))\n                                                        (do\n                                                          (q/fill 100 255 100)\n                                                          (q/no-stroke)\n                                                          (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)\n                                                          )\n                                                        )\n                (when (= 1 (cell :path))\n                  (do\n                    (q/fill 200 240 0)\n                    (q/no-stroke)\n                    (q/rect (+ xv (/ (/ x-cell-size 2) 2)) (+ yv (/ (/ y-cell-size 2) 2)) (/ x-cell-size 2) (/ y-cell-size 2))))\n\n                (q/image (q/load-image \&quot;./mouse.jpg\&quot;) xv yv x-cell-size y-cell-size)\n                (q/stroke 0)\n                (q/stroke-weight 5)\n                (q/fill 0)\n                (when (= 0 (cell :east)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv2 yv xv2 yv2)))\n                (when (= 0 (cell :west)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv yv2)))\n                (when (= 0 (cell :south)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv2 xv2 yv2)))\n                (when (= 0 (cell :north)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv2 yv)))\n                (when (&gt; 14 (count maze)) (q/text-size 20))\n                (when (&gt; 14 (count maze)) (q/text (str (cell :weight)) (+ xv (/ x-cell-size 2)) (+ yv (/ y-cell-size 2))))))))))))&quot;, :offset 3327, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(defn get-drawn-maze\n  [state]\n  (let [maze (find-route 0 0 5 5 (dijkstras (state :mask) (make-maze (state :maze-size) (state :maze-size) (state :mask)))) margin 70]\n    (q/fill 0)\n    (q/background 240)\n    (q/line margin margin (- (state :width) margin) margin)\n    (let [y-cell-size (/ (- (state :height) (* 2 margin)) (count maze))\n          x-cell-size (/ (- (state :width) (* 2 margin)) (-&gt; maze first count))]\n      (dotimes [y (count maze)]\n        (let [yv (+ margin (* y y-cell-size))\n              yv2 (+ y-cell-size yv)]\n          (q/line margin yv margin yv2)\n          (dotimes [x (-&gt; maze first count)]\n            (let [xv (+ margin (* x x-cell-size))\n                  xv2 (+ x-cell-size xv)]\n              ;(if (= 0 ((mget x y maze) :south) (q/line xv yv2 xv2 yv2))\n              ;(if (not= 0 ((mget x y maze) :north))\n              ;  (when (= 0 ((mget x y maze) :east) (q/line xv yv2 xv2 yv2))\n              ;  (q/line xv2 yv xv2 yv2))))\n              (let [cell (get-in maze [y x])\n                    maskCell (get (get (state :mask) y) x)]\n                (if (or (nil? maskCell) (= 0 maskCell)) (if (= 0 (cell :visited))\n                                                          (do\n                                                            (q/fill 200 255 200)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size))\n                                                          (do\n                                                            (q/fill (- 255 (cell :weight)) 50 100)\n                                                            (q/no-stroke)\n                                                            (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)))\n                                                        (do\n                                                          (q/fill 100 255 100)\n                                                          (q/no-stroke)\n                                                          (q/rect (+ 3 xv) (+ 3 yv) x-cell-size y-cell-size)\n                                                          )\n                                                        )\n                (when (= 1 (cell :path))\n                  (do\n                    (q/fill 200 240 0)\n                    (q/no-stroke)\n                    (q/rect (+ xv (/ (/ x-cell-size 2) 2)) (+ yv (/ (/ y-cell-size 2) 2)) (/ x-cell-size 2) (/ y-cell-size 2))))\n\n                (q/image (q/load-image \&quot;./mouse.jpg\&quot;) 500 500)\n                (q/stroke 0)\n                (q/stroke-weight 5)\n                (q/fill 0)\n                (when (= 0 (cell :east)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv2 yv xv2 yv2)))\n                (when (= 0 (cell :west)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv yv2)))\n                (when (= 0 (cell :south)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv2 xv2 yv2)))\n                (when (= 0 (cell :north)) (when (or (nil? maskCell) (= 0 maskCell)) (q/line xv yv xv2 yv)))\n                (when (&gt; 14 (count maze)) (q/text-size 20))\n                (when (&gt; 14 (count maze)) (q/text (str (cell :weight)) (+ xv (/ x-cell-size 2)) (+ yv (/ y-cell-size 2))))))))))))&quot;, :offset 3305, :ns &quot;compojure-api-test.mazegenerator&quot;} {:command &quot;(q/sketch\n  :draw (fn []\n          (q/do-record (q/create-graphics 750 750 :svg \&quot;test.svg\&quot;)\n                       (q/no-loop)\n                       (get-drawn-maze {:maze-size 32 :mask [] :width 750 :height 750})\n                       )\n          (q/exit)\n          ))&quot;, :offset 271, :ns &quot;compojure-api-test.mazegenerator&quot;}], :remote []}}</component>
  <component name="RunManager" selected="Clojure REPL.REPL">
    <configuration name="REPL" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <module name="compojure-api-test" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <setting name="fixLineNumbers" value="false" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="SOCKET" />
      <setting name="configType" value="SPECIFY" />
      <setting name="fixLineNumbers" value="false" />
      <module name="" />
      <method v="2" />
    </configuration>
    <configuration name="Lein" type="LeiningenRunConfiguration" factoryName="Leiningen">
      <module name="compojure-api-test" />
      <arguments argument="ring" />
      <arguments argument="server" />
      <setting name="profiles" value="" />
      <setting name="trampoline" value="false" />
      <method v="2" />
    </configuration>
    <list>
      <item itemvalue="Clojure REPL.REPL" />
      <item itemvalue="Leiningen.Lein" />
    </list>
  </component>
  <component name="SbtLocalSettings">
    <option name="projectSyncType">
      <map>
        <entry key="$PROJECT_DIR$/../../Project/GitHub/anyplace/server" value="PREVIEW" />
      </map>
    </option>
  </component>
  <component name="ServiceViewManager">
    <option name="viewStates">
      <list>
        <serviceView>
          <treeState>
            <expand />
            <select />
          </treeState>
        </serviceView>
      </list>
    </option>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="dd9e511f-3a1e-4bd8-9538-ea0d0c0580e3" name="Default Changelist" comment="" />
      <created>1582384641647</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1582384641647</updated>
    </task>
    <servers />
  </component>
  <component name="WindowStateProjectService">
    <state x="414" y="-957" width="1092" height="917" key="#com.intellij.execution.impl.EditConfigurationsDialog" timestamp="1582384898658">
      <screen x="0" y="-1080" width="1920" height="1040" />
    </state>
    <state x="414" y="-957" width="1092" height="917" key="#com.intellij.execution.impl.EditConfigurationsDialog/0.0.1536.824/0.-1080.1920.1040@0.-1080.1920.1040" timestamp="1582384898658" />
    <state x="470" y="114" key="CommitChangelistDialog2" timestamp="1582897946321">
      <screen x="0" y="0" width="1920" height="1040" />
    </state>
    <state x="470" y="114" key="CommitChangelistDialog2/0.0.1920.1040@0.0.1920.1040" timestamp="1582897946321" />
    <state width="1877" height="143" key="GridCell.Tab.0.bottom" timestamp="1582902252969">
      <screen x="0" y="0" width="1920" height="1040" />
    </state>
    <state width="1877" height="282" key="GridCell.Tab.0.bottom/0.0.1536.824/0.-1080.1920.1040@0.-1080.1920.1040" timestamp="1582396295489" />
    <state width="1493" height="160" key="GridCell.Tab.0.bottom/0.0.1536.824@0.0.1536.824" timestamp="1582419443901" />
    <state width="1877" height="173" key="GridCell.Tab.0.bottom/0.0.1920.1040/-1920.0.1920.1040@0.0.1920.1040" timestamp="1582709230806" />
    <state width="1877" height="173" key="GridCell.Tab.0.bottom/0.0.1920.1040/1920.0.1536.824@0.0.1920.1040" timestamp="1582625788064" />
    <state width="1877" height="143" key="GridCell.Tab.0.bottom/0.0.1920.1040@0.0.1920.1040" timestamp="1582902252969" />
    <state width="1877" height="143" key="GridCell.Tab.0.center" timestamp="1582902252969">
      <screen x="0" y="0" width="1920" height="1040" />
    </state>
    <state width="1877" height="282" key="GridCell.Tab.0.center/0.0.1536.824/0.-1080.1920.1040@0.-1080.1920.1040" timestamp="1582396295488" />
    <state width="1493" height="160" key="GridCell.Tab.0.center/0.0.1536.824@0.0.1536.824" timestamp="1582419443900" />
    <state width="1877" height="173" key="GridCell.Tab.0.center/0.0.1920.1040/-1920.0.1920.1040@0.0.1920.1040" timestamp="1582709230806" />
    <state width="1877" height="173" key="GridCell.Tab.0.center/0.0.1920.1040/1920.0.1536.824@0.0.1920.1040" timestamp="1582625788063" />
    <state width="1877" height="143" key="GridCell.Tab.0.center/0.0.1920.1040@0.0.1920.1040" timestamp="1582902252969" />
    <state width="1877" height="143" key="GridCell.Tab.0.left" timestamp="1582902252969">
      <screen x="0" y="0" width="1920" height="1040" />
    </state>
    <state width="1877" height="282" key="GridCell.Tab.0.left/0.0.1536.824/0.-1080.1920.1040@0.-1080.1920.1040" timestamp="1582396295488" />
    <state width="1493" height="160" key="GridCell.Tab.0.left/0.0.1536.824@0.0.1536.824" timestamp="1582419443900" />
    <state width="1877" height="173" key="GridCell.Tab.0.left/0.0.1920.1040/-1920.0.1920.1040@0.0.1920.1040" timestamp="1582709230806" />
    <state width="1877" height="173" key="GridCell.Tab.0.left/0.0.1920.1040/1920.0.1536.824@0.0.1920.1040" timestamp="1582625788063" />
    <state width="1877" height="143" key="GridCell.Tab.0.left/0.0.1920.1040@0.0.1920.1040" timestamp="1582902252969" />
    <state width="1877" height="143" key="GridCell.Tab.0.right" timestamp="1582902252969">
      <screen x="0" y="0" width="1920" height="1040" />
    </state>
    <state width="1877" height="282" key="GridCell.Tab.0.right/0.0.1536.824/0.-1080.1920.1040@0.-1080.1920.1040" timestamp="1582396295488" />
    <state width="1493" height="160" key="GridCell.Tab.0.right/0.0.1536.824@0.0.1536.824" timestamp="1582419443901" />
    <state width="1877" height="173" key="GridCell.Tab.0.right/0.0.1920.1040/-1920.0.1920.1040@0.0.1920.1040" timestamp="1582709230806" />
    <state width="1877" height="173" key="GridCell.Tab.0.right/0.0.1920.1040/1920.0.1536.824@0.0.1920.1040" timestamp="1582625788063" />
    <state width="1877" height="143" key="GridCell.Tab.0.right/0.0.1920.1040@0.0.1920.1040" timestamp="1582902252969" />
    <state x="277" y="55" key="SettingsEditor" timestamp="1582419259684">
      <screen x="0" y="0" width="1536" height="824" />
    </state>
    <state x="277" y="55" key="SettingsEditor/0.0.1536.824@0.0.1536.824" timestamp="1582419259684" />
    <state x="655" y="344" key="com.intellij.ide.util.TipDialog" timestamp="1582880480074">
      <screen x="0" y="0" width="1920" height="1040" />
    </state>
    <state x="655" y="344" key="com.intellij.ide.util.TipDialog/0.0.1920.1040/1920.0.1920.1040@0.0.1920.1040" timestamp="1582726242798" />
    <state x="655" y="344" key="com.intellij.ide.util.TipDialog/0.0.1920.1040@0.0.1920.1040" timestamp="1582880480074" />
    <state x="420" y="145" width="694" height="678" key="search.everywhere.popup" timestamp="1582419257155">
      <screen x="0" y="0" width="1536" height="824" />
    </state>
    <state x="420" y="145" width="694" height="678" key="search.everywhere.popup/0.0.1536.824@0.0.1536.824" timestamp="1582419257155" />
  </component>
</project>